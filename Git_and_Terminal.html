<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Git / Terminal</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap"
      rel="stylesheet"
    />
    <link rel="icon" href="./images/Logo MateAcademy.png" />
    <link rel="stylesheet" href="style/fontello.css" />
    <link rel="stylesheet" href="style/main.css" />
    <style>
      .Setup_for_Windows img {
        display: block;
        width: 100%;
        margin: 40px 0;
      }
      .bord__left {
        border-left: 5px solid rgba(96, 95, 95, 0.5);
        padding-left: 10px;
      }
    </style>
  </head>
  <body>
    <section class="nav-bar">
      <div class="nav">
        <a href="index.html">Index</a>
        <a href="Git_and_Terminal.html">Git and Terminal</a>
        <a href="JS_Basics _Extended.html">JS Basics Extended</a>
        <a href="HTML_CSS_Advanced.html">HTML + CSS Advanced</a>
        <a href="BEM.html">BEM</a>
        <a href="SASS.html">SASS</a>
        <a href="Transf and Animations.html">SASS</a>
      </div>
    </section>
    <!-- Меню страници по Секциям -->
    <select class="menu-pege Select-section" name="menu-pege" >
      <option value="">-- Select section --</option>
      <option value="#setup">Setup for Windows</option>
      <option value="#Command">Command-Line</option>
      <option value="#list_Command">list Command Git</option>
      <option value="#Git">Git-Basics</option>
      <option value="#branch">Branch</option>
      <option value="#Git-Hub">Working-GitHub</option>
    </select>
    <section class="Environment_Setup" id="setup">
      <div class="container">
        <div class="Setup_for_Windows">
          <h3>Налаштування середовища для Windows</h3>
          <p>
            В цьому уроці ти встановиш VSCode та Git, які знадобляться тобі
            протягом курсу. Git - це система контролю версій. VSCode - це
            безкоштовний та зручний редактор коду. Ми будемо використовувати
            його для деяких прикладів.
          </p>
          <h3>Встановлення VSCode (Windows)</h3>
          <ol>
            <li>Завантаж VSCode.</li>
            <li>Запусти файл як завжди (НЕ як Адміністратор).</li>
            <li>Продовжуй до кроку Select Additional Tasks.</li>
            <li>
              Обери наступні опції:
              <ul>
                <li>
                  Add "Open with Code" action ... дозволяє тобі відкривати файли
                  та папки з контекстного меню (правою клавішею миші); Register
                  Code ... дозволить відкривати підтримувані файли в VSCode
                  після подвійного кліку; Add to PATH дозволить запускати VSCode
                  з Терміналу за допомогою команди code.
                  <img
                    src="https://media.mate.academy/select_additional_6fd7825674.png"
                    alt="picture setap"
                  />
                </li>
              </ul>
            </li>
            <li>Продовжуй до завершення.</li>
          </ol>
          <h3>Встановлення Git (Windows)</h3>
          <ol>
            <li>Завантаж Git. Краще обрати 64-бітну версію.</li>
            <li>Запусти файл як завжди (НЕ як Адміністратор).</li>
            <li>Продовжуй до кроку Select Components.</li>
            <li>
              На додачу до обраних компонентів, обери всі опції зі списку
              Windows Explorer integration та опцію Add a Git Bash Profile to
              Windows Terminal.
              <img
                src="https://media.mate.academy/git_select_components_8dc74d61ce.png"
                alt="picture Git"
              />
            </li>
            <li>
              На кроці Choosing the default editor used by Git, обери опцію Use
              the Nano editor by default.
              <img
                src="https://media.mate.academy/git_choose_default_editor_c7c66e19bb.png"
                alt="picture  editor"
              />
            </li>
            <li>
              На кроці Adjusting your PATH environment, переконайся, що обрана
              рекомендована опція.
              <img
                src="https://media.mate.academy/git_adjust_path_env_e3dc4dbc4c.png"
                alt=" Adjusting"
              />
            </li>
            <li>
              На кроці Configuring the line ending, обери останній пункт Check
              out as-is, commit as-is.
              <img
                src="https://media.mate.academy/git_configure_line_ending_0e0ce11826.png"
                alt="Configuring"
              />
            </li>
            <li>
              Коли встановлення завершиться, обери пункт Launch Git Bash та
              натисни Finish.
            </li>
            <li>
              Набери git --version та натисни клавішу Enter в терміналі Git
              Bash, щоб перевірити, чи git працює.
              <img
                src="https://media.mate.academy/win_git_version_486fcd1339.png"
                alt="picture version"
              />
            </li>
            <p class="bord__left">
              В майбутньому завжди використовуй термінал Git Bash, а не інші
              термінали Windows для всіх команд, щоб уникнути можливих
              несумісностей.
            </p>
          </ol>
          <h3>Глобальні налаштування Git (Windows)</h3>
          <p>
            Відкрий Git Bash та запусти ці команди по черзі зі своїм іменем та
            поштою, щоб завершити налаштування Git (зміни текст у лапках ""
            перед натисканням клавіші Enter):
          </p>
          <!-- Нужно завершить перенос инормации !!! -->
        </div>
      </div>
    </section>
    <section class="Command-Line" id="Command">
      <div class="container">
        <div class="Managing_files_directories releative__block">
          <h3 class="main-topic-title">Управление файлами и каталогами</h3>
          <p>
            Далее мы обсудим команды, которые позволяют создавать, редактировать
            и удалять файлы и каталоги.
          </p>
          <ul>
            <li><b>touch file.name</b> - Создать пустой файл</li>
            <li><b>cat file.name</b> - Отобразить содержимое файла</li>
            <li>
              <b>cat > file.name</b> - Создать файл и ввести его содержимое
              построчно
            </li>
            <li><b>mkdir dirname</b> - Создать новый каталог</li>
            <li>
              <b>mkdir -p dir1/dir2/dir3</b> - Создать каталоги рекурсивно
            </li>
            <li>
              <b>mv path/to/name path/to/existing-folder</b> - Переместить файл
              или папку в другой каталог
            </li>
            <li>
              <b>mv path/to/name path/to/non-existing-name</b> - Переименовать
              файл или папку
            </li>
            <li>
              <b>cp path/to/file path/to/new-file-name</b> - Копировать файл в
              новую директорию с новым иминем.
            </li>
            <li>
              <b>cp -r path/to/folder path/to/new-folder-name</b> - Копировать
              директорию в новую директорию.
            </li>
            <li>
              <b>
                <u> rm path/to/file</u>
              </b>
              - Удалить файл
            </li>
            <li>
              <b><u>rm -r</u> path/to/folder </b> - Удалить папку вместе со всем
              ее содержимым
            </li>
            <li>
              <b><u>rm -r path/*</u></b> - Удалить все содержимое указанной
              папки
            </li>
            <li>
              <b><u>rm -rf</u> path/to/folder</b> - Удалить папку без запроса
              дополнительных подтверждений
            </li>
          </ul>
          <h3>Creating Files</h3>
          <p>
            Команда cat > file.name позволяет создать файл и ввести его
            содержимое построчно.
          </p>

          <p>
            С помощью команды <b>cat file.name</b> можно отобразить содержимое
            файла на экране.
          </p>

          <p>
            Команда <b>touch</b> позволяет создать пустой файл,
            <u>указав его путь:</u>
          </p>
          <pre>
            touch ./project-folder/readme.md
          </pre>
          <h3>Создание каталогов</h3>
          <p>
            Команда mkdir отвечает за создание каталогов. Ключ -p позволяет
            создавать несколько вложенных каталогов.
          </p>
          <pre>
            mkdir -p parent/child/grand-child
          </pre>
          <p>
            <b>Переименование и перемещение файлов и папок</b>
          </p>
          <p>
            Команда
            <b><u>cp</u> path/to/file path/to/new-file-name</b> позволяет
            создать копию файла.
          </p>
          <p>
            Чтобы скопировать каталог, необходимо добавить ключ -r (рекурсивно),
            чтобы он был скопирован вместе со всем его содержимым.
          </p>
          <p>
            <b>Удаление файлов и папок</b>
          </p>
          <p>
            По умолчанию команда <b>rm</b> удаляет только обычные файлы. Для
            системных файлов она запросит подтверждение. Чтобы удалить без
            необходимости ручного подтверждения, можно добавить флаг -f. <br />
            Также можно указать несколько файлов через пробел, чтобы удалить их
            вместе. <br />
            Чтобы удалить каталоги, нужно добавить ключ <b>-r</b> (рекурсивно).
            Его можно объединить с ключом <b>-f:</b>
          </p>
          <pre>
            rm -rf node-modules
          </pre>
          <p>
            <u
              >* в пути означает любое имя, поэтому rm -r src/* удалит все
              содержимое каталога src.</u
            >
          </p>
          <p>
            <b>Шпаргалка по полезным командам терминала</b>
          </p>
          <p>Basic Commands</p>
          <ul>
            <li><b>clear</b> - Очистить окно терминала</li>
            <li>
              <b>man some-command</b> - Показать документацию для указанной
              команды в MacOS
            </li>
            <li>
              <b>some-command --help</b> - Показать документацию для указанной
              команды
            </li>
            <li>
              в Windows <b>which some-command</b> - Найти местоположение команды
            </li>
            <li><b>echo</b> - Показать какой-то текст</li>
            <li><b>echo $PATH</b> - Показать переменную окружения PATH</li>
          </ul>
          <p>
            <b>Файлы и Папки</b>
          </p>
          <ul>
            <li><b>pwd</b> - Вывести текущий путь к каталогу</li>
            <li><b>ls path/to/folder</b> - Отобразить содержимое папки</li>
            <li><b>ls -l path</b> - Отобразить содержимое в виде списка</li>
            <li><b>ls -a path</b> - Показать скрытое содержимое</li>
            <li><b>ls -t path</b> - Сортировать содержимое по дате</li>
            <li><b>cd path/to/folder</b> - Изменить текущий каталог</li>
            <li><b>touch file.name</b> - Создать пустой файл</li>
            <li><b>cat file.name</b> - Отобразить содержимое файла</li>
            <li>
              <b>cat > file.name</b> - Создать файл и ввести содержимое
              построчно
            </li>
            <li><b>mkdir dirname</b> - Создать новый каталог</li>
            <li>
              <b>mkdir -p dir1/dir2/dir3</b> - Создать каталоги рекурсивно
            </li>
            <li>
              <b>mv path/to/name path/to/existing-folder</b> - Переместить файл
              или папку в другой каталог
            </li>
            <li>
              <b>mv path/to/name path/to/non-existing-name</b> - Переименовать
              файл или папку
            </li>
            <li>
              <b>cp path/to/file path/to/new-file-name</b> - Копировать файл
            </li>
            <li>
              <b>cp -r path/to/folder path/to/new-folder-name</b> - Копировать
              каталог
            </li>
            <li><b>rm path/to/file</b> - Удалить file</li>
            <li>
              <b>rm -r path/to/folder</b> - Удалить папку вместе со всем ее
              содержимым
            </li>
            <li><b>rm -r path/*</b> - Удалить все внутри указанной папки</li>
            <li>
              <b>rm -rf path/to/folder</b> - Удалить папку без запроса
              дополнительных подтверждений
            </li>
            <li><b>head -n 5 fileName</b> - Показать первые 5 строк файла</li>
            <li>
              <b>tail -f file</b> - Показать последние 10 строк файла и
              дождаться обновлений
            </li>
            <li>
              <b>grep pattern file</b> - Найти все совпадения шаблона в файле
            </li>
            <li>
              <b>less path/to/file</b> - Открыть файл в Less (текстовый
              просмотрщик командной строки)
            </li>
            <li>
              <b>nano path/to/file</b> - Открыть файл в Nano (текстовый редактор
              командной строки)
            </li>
            <li><b>code path/to/file</b> - Открыть файл в VSCode</li>
          </ul>
          <h3>Command History</h3>
          <ul>
            <li><b>Arrow UP</b> - Стрелка ВВЕРХ Показать предыдущую команду</li>
            <li><b>Arrow DOWN</b> - Стрелка ВНИЗ Показать следующую команду</li>
            <li><b>history</b> - Показать историю команд</li>
            <li><b>history -c</b> - Очистить историю команд</li>
            <li><b>!!</b> -Выполнить последнюю команду из истории</li>
            <li><b>!12</b> -Выполнить 12-ю команду из истории</li>
            <li>
              <b>!some-text</b> - Выполнить последнюю команду из истории,
              которая начинается с указанного текста
            </li>
            <li><b>CTRL + R</b> - Поиск в истории команд</li>
          </ul>
        </div>
        <div class="Useful-links">
          <ul>
            <li><b>" /"</b> - root folder (MacOS)</li>
            <li><b>"C:/, D:/"</b> - disk root (Windows)</li>
            <li><b>"~"</b> - home folder</li>
            <li><b>"."</b> - current folder</li>
            <li><b>".."</b> - Parent folder</li>
            <li><b>"../.."</b> - 2 level up folder</li>
            <li><b>"*"</b> - Any path</li>
            <li>
              <b>"img/*.png"</b> - all the <b>png</b> files in <b>img folder</b>
            </li>
          </ul>
          <p>
            <a
              href="https://docs.google.com/document/d/1lCt8y3kz62z5dAlMvJ7kQRWouHJRkr991cBHc1bhSbU/edit#heading=h.w1hy05o1ju5m"
              >Git & Terminal Recap</a
            >
          </p>
        </div>
      </div>
    </section>
    <section class="Git-Basics" id="Git">
      <div class="container">
        <div class="git-commands">
          <h3>Основи Git</h3>
          <hr />
          <p>
            Кожна комп'ютерна програма складається з файлів, які містять певні
            інструкції. Файлів може бути дуже багато: десятки, сотні або навіть
            тисячі. Тому фізично неможливо запам’ятати, що і коли змінювалося в
            кожному з них. Крім того, над проєктом зазвичай працює кілька
            розробників, хтось приєднується, хтось йде. Інколи буває необхідно
            повернутися до попередньої версії програми чи окремих файлів,
            наприклад, через нестабільність або зміну планів. В цій ситуації на
            допомогу приходить система контролю версій.
          </p>
          <p>
            Система контролю версій дозволяє контролювати та зберігати історію
            змін у файлах. І, за потреби, швидко перемикатися між версіями.
          </p>
          <p>Найпопулярнішою системою контролю версій є Git.</p>
          <p>
            <b>Як працює Git</b>
          </p>
          <p>
            Кожного разу, коли ми зберігаємо зміни, Git створює так званий
            commit, який містить так звану delta (що було додано або видалено)
            для змінених файлів. Кожне таке збереження підписується контрольною
            хеш-сумою (SHA-1), яка розраховується на основі вмісту,
            повідомлення, автора та часу. Таким чином, неможливо змінити файл чи
            директорію так, щоб Git про це не дізнався. Варто зазначити, що Git
            зберігає всі зміни локально, тобто лише на пристрої користувача.
          </p>
          <p>
            <u>А тепер до практики!</u>
          </p>
          <p>
            <b>Ініціюємо репозиторій та готуємо файли до збереження</b>
          </p>
          <p>
            Хоч Git і можна вважати супермозком, проте це не штучний інтелект,
            який самостійно приймає рішення щодо збереження файлів. Для початку
            Git потрібно активувати. Директорія, у якій активовано Git,
            називається репозиторієм. Щоб звичайна директорія стала Git
            репозиторієм, у ній повинна бути прихована папка .git. Створити цю
            папку і, відповідно, активувати Git репозиторій можна за допомогою
            команди:
          </p>
          <pre>
            git init
          </pre>
          <p>Щоб видалити репозиторій, достатньо видалити папку .git.</p>
          <p>
            Усі зміни в репозиторії можна простежити за допомогою команди git
            status. Ця команда покаже наступне:
          </p>
          <ol>
            <li>
              Чи активовано репозиторій у поточній директорії.
              <img
                src="https://media.mate.academy/img1_b5a53f98b0.png"
                alt=""
              />
            </li>
            <li>
              Чи є файли, які Git ще не відстежує (untracked files) або чи були
              внесені зміни у файли, які Git відстежує (modified).
            </li>
            <li>
              Чи є змінені файли, підготовлені до збереження — внесені в індекс
              (changes to be committed).
              <img
                src="https://media.mate.academy/img2_03b7a4f4a7.png"
                alt=""
              />
            </li>
          </ol>
          <p>
            <b>Індекс — </b>це файл, який зазвичай знаходиться в директорії Git
            та містить інформацію про те, що буде збережено в наступному коміті.
            Додати файли в індекс (підготувати зміни до збереження) можна:
          </p>
          <ul>
            <li>поодинці для кожного файлу — git add ./path/to/file;</li>
            <li>
              кілька файлів одночасно, прописавши їх назви або ж шлях до файлів
              через пробіл — git add ./path/to/file ./path/to/another/file;
            </li>
            <li>
              усі файли, що знаходяться в певній директорії — git add
              path/to/folder;
            </li>
            <li>одразу всі файли в поточній директорії — git add ..</li>
          </ul>
          <p>
            Нагадаємо, що Git робить «скріншот» рядків, які містяться у файлі на
            певний момент. Так от, тим моментом є додавання файлу в індекс.
            Тобто, якщо у файл, який перебуває в індексі, внести зміни, то ці
            зміни не потраплять в індекс, їх треба буде додавати знов.
          </p>
          <img src="https://media.mate.academy/img3_6e51cf88b7.png" alt="" />
          <p>
            Зверни увагу, що Git «спілкується» з користувачем. Як бачимо з
            зображення вище, Git пропонує виконати певні команди, щоб рухатись
            далі.
          </p>
          <p>
            Якщо треба скасувати зміни, внесені у файл, який ще не додано в
            індекс, можна виконати команду:
          </p>
          <code>git restore file_name</code>
          <p>Якщо файл помилково додано в індекс, слід виконати команду:</p>
          <code>git restore --staged file_name </code>
          <h3 class="topic-title">Файл .gitignore</h3>
          <p>
            Щоб Git не відстежував певні файли в репозиторії або ж не змінював
            уже збережені в репозиторії файли, можна використати прихований файл
            .gitignore. Його потрібно створити в кореневій директорії
            репозиторію (на одному рівні з папкою .git) та помістити в нього
            назви всіх файлів, які Git повинен ігнорувати.
          </p>
          <h3 class="topic-title">Коміти</h3>
          <hr />
          <p>
            Файли, підготовлені до збереження, можна зберегти командою git
            commit. Після цієї команди відкриється текстовий редактор, де
            потрібно буде ввести пояснення до коміту (commit message).
          </p>
          <img
            src="https://media.mate.academy/img4_c8f7cd2018.png"
            alt="page git commit"
          />
          <p>Щоб додати пояснення одразу, можна використати ключ -m:</p>
          <code>git commit -m "do something" </code>
          <p>
            Таким чином, за допомогою команд git commit та git commit -m "do
            something" ми збережемо всі файли, додані до індексу (підготовлені
            до збереження). Можна уникнути кроку додавання файлів до індексу,
            вписавши прапорець -a в команду git commit, що означає зберегти всі
            змінені файли. З прапорцем -a потрібно бути дуже обережними, адже
            можемо зберегти зайві файли:
          </p>
          <code>git commit -am "do something" </code>
          <h3 class="topic-title">Історія комітів</h3>
          <hr />
          <p>
            Кожен коміт зберігається в історії комітів. Щоб вивести її на екран,
            використай команду git log
          </p>
          <img
            src="https://media.mate.academy/img5_89966d1fae.png"
            alt="picture page log commits"
          />
          <p>
            Ця команда показує хеш кожного коміту, ім'я та пошту автора, дату
            збереження та повідомлення коміту. З більш детальним описом опцій
            цієї команди можна ознайомитись у документі
            <a
              href="https://git-scm.com/book/en/v2/Git-Basics-Viewing-the-Commit-History"
              >Viewing the Commit History
            </a>
            . Щоб зробити історію комітів більш читабельною, можна використати
            аліас, про що ми поговоримо далі.
          </p>
          <p>
            Перемикатися між збереженнями можна за допомогою гілок або хешу
            коміту, використовуючи команду
            <code>git checkout hash-or-branch</code>. Зазвичай 7 перших символів
            хешу достатньо, щоб перемикнутися між комітами.
          </p>
          <h3 class="topic-title">Аліаси</h3>
          <p>
            Кожну команду Git можна «перейменувати» чи «скоротити» за допомогою
            аліасів. Усі аліаси зберігаються в прихованому файлі ~/.gitconfig.
            Додати аліас можна командою:
          </p>
          <code>git config --global alias.alias_name command_name </code>
          <p>
            Внести зміни у <b>.gitconfig</b> можна не тільки через командний
            рядок, але й відкривши цей файл у будь-якому текстовому редакторі.
            Ми пропонуємо внести такі зміни у файл <b>.gitconfig:</b>
          </p>
          <pre>
            [user]
              name = Your_Name Your_Surname
              email = your@email
            [alias]
              ci = commit
              co = checkout
              br = branch
              st = status
              lg = log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit --branches
            [core]
              pager = 
              editor = nano
          </pre>
          <p>
            Як бачиш, у файлі прописано аліас для команди git log. Цей аліас
            зробить історію комітів більш читабельною.
          </p>
          <img
            src="https://media.mate.academy/img6_ae1a284cdf.png"
            alt="picture git log"
          />
          <h3 class="topic-title" id="list_Command">Основні команди</h3>
          <hr />
          <ul>
            <li>git config --global ... Встановити глобальні параметри Git</li>
            <li>
              git init Ініціалізувати новий Git репозиторій у поточній
              директорії
            </li>
            <li>git status Показати інформацію про репозиторій</li>
            <li>
              git add ./path/to/files Підготувати зміни файлу для збереження
            </li>

            <li>
              git restore file_name Скасувати зміни в модифікованому файлі
              file_name
            </li>
            <li>
              git restore --staged file_name Видалити файл file_name з індексу
            </li>
            <li>
              git commit Відкрити текстовий редактор, щоб ввести повідомлення
              для коміту та зберегти зміни в індексі
            </li>
            <li>
              git commit -m 'do something' Зберегти зміни із вказаним
              повідомленням
            </li>
            <li>
              git commit -am 'do something' Підготувати всі змінені файли та
              зберегти із вказаним повідомленням
            </li>
            <li>git log Показати історію комітів</li>
            <li>git lg Аліас, який ми створили для log</li>
            <li>git branch Показати всі гілки</li>
            <li>git branch branch_name Створити нову гілку branch_name</li>
            <li>git branch -D branch_name Видалити гілку branch_name</li>
            <li>
              git checkout hash-or-branch Перейти на іншу гілку або хеш коміту
            </li>
          </ul>
        </div>
      </div>
    </section>
    <section class="Useful-links">
      <div class="container">
        <h3 class="main-topic-title">Корисні посилання</h3>
        <hr />
        <p>
          <a
            href="https://docs.google.com/document/d/1lCt8y3kz62z5dAlMvJ7kQRWouHJRkr991cBHc1bhSbU/edit"
            >Git & Terminal Recap</a
          >
        </p>
        <p><a href="https://git-scm.com/book/en/v2">Git Book</a></p>
        <p>
          <a
            href="https://git-scm.com/book/en/v2/Appendix-A:-Git-in-Other-Environments-Git-in-Zsh"
            >Git in Zsh</a
          >
        </p>
        <p><a href="https://ohmyz.sh/">Oh My ZSH!</a></p>
        <p><a href="https://githowto.com/">GitHowTo tutorial</a></p>
      </div>
    </section>
    <section class="branch" id="branch">
      <div class="container">
        <div class="Working With Branches releative__block">
          <h3 class="main-topic-title">Робота з гілками</h3>
          <hr />
          <p>
            Після ініціалізації репозиторію, у терміналі біля імені директорії
            з'являється назва поточної (активної) гілки.
          </p>
          <p>
            <b>Гілка</b> — це додаткове ім'я, яке ми даємо до коміту
            (збереження), щоб не запам'ятовувати його хеш. Вони використовуються
            для паралельної роботи над кількома завданнями та дозволяють
            уникнути конфліктів на момент злиття змін. За замовчуванням,
            основною є гілка main (або master), але можна використовувати й
            будь-яку іншу. Код основної гілки зазвичай використовується для
            публікації стабільної версії продукту (сайту або додатку).
          </p>
          <h3 class="main-topic-title">Управління гілками</h3>
          <hr />
          <p>
            Уявімо ситуацію, коли репозиторій щойно був активований і в ньому
            створено три коміти. Активна гілка (та, у якій ведеться розробка)
            відзначена вказівником HEAD в історії.
          </p>
          <img
            src="https://media.mate.academy/img1_79272b085f.png"
            alt="picture menegment branch"
          />
          <p>Список гілок можна подивитися за допомогою команди:</p>
          <pre>git branch</pre>
          <p>Створити нову гілку на поточному коміті можна такою командою:</p>
          <pre>
            git branch branch_name
          </pre>
          <p>Перейти на іншу гілку можна за допомогою команд:</p>
          <pre>
            git checkout branch_name
            git switch branch_name
          </pre>
          <p>Також можна створити гілку та відразу на неї перейти:</p>
          <pre>
            git checkout -b branch_name
            git switch -c branch_name
          </pre>
          <p>
            Якщо при створенні гілки було допущено помилку, її можна
            перейменувати:
          </p>
          <pre>
            git branch -m new_name
          </pre>
          <p>Це перейменує лише активну гілку.</p>
          <p>
            Видалити можна лише неактивну гілку. Для цього використовується ключ
            -d:
          </p>
          <pre>
            git branch -d branch_name
          </pre>
          <p>
            Якщо на одному коміті знаходяться кілька гілок, то при збереженні
            активна гілка переміщається на новий коміт, а неактивні залишаються
            на попередньому.
          </p>
          <p>
            Для додавання змін із вибраної гілки в активну треба запустити
            команду:
          </p>
          <pre>
            git merge branch_name
          </pre>
          <ul>
            При цьому:
            <li>
              якщо активна гілка знаходиться десь раніше в історії комітів, ніж
              вибрана гілка, то вона просто переходить на той же коміт, де зараз
              знаходиться гілка, що зливається;
            </li>
            <li>
              якщо ж ні, то створюється новий коміт, де будуть усі зміни з
              активної гілки та вибраної гілки, а активна гілка переміщається на
              цей новий коміт;
            </li>
            <li>
              при цьому, якщо зміни вносилися в ті самі рядки коду, то виникне
              конфлікт, і потрібно буде вручну вибрати, яку версію змін додати
              до фінальної версії.
            </li>
          </ul>
          <h3 class="main-topic-title">Скасування змін</h3>
          <hr />
          <p>
            Щоб створити новий коміт зі змінами, протилежними змінам у вибраному
            коміті, можна використати команду:
          </p>
          <pre>
            git revert hash
          </pre>
          <p>Де hash — це хеш (ідентифікатор) коміту.</p>
          <p>Щоб переставити гілку на вказаний коміт, можна запустити:</p>
          <pre>
            git reset hash
          </pre>
          <p>
            Ця команда змінює історію комітів, тому її варто використовувати
            тільки для не публічних гілок, щоб уникнути можливих проблем при
            злитті.
          </p>
          <p>
            При цьому зміни залишаються у файлах, де вони були зроблені. Ключ
            --hard дозволяє скинути зміни:
          </p>
          <pre>
            git reset HEAD^^ --hard
          </pre>
          <p>
            HEAD^^ означає, що активна гілка переміщається назад на 2 коміти,
            тому й всі зміни у файлах будуть стерті. Замість HEAD^^ можна
            використовувати хеш коміта.
          </p>
          <img
            src="https://media.mate.academy/img2_4702449ba5.png"
            alt="picture branch"
          />
          <h3 class="main-topic-title">Лінійна та нелінійна історія змін</h3>
          <hr />
          <p>
            Іноді буває зручно, щоб історія змін основної гілки була лінійною
            (без розгалужень). Ось приклад, коли всі збереження розташовані один
            за одним:
          </p>
          <img src="https://media.mate.academy/img3_9303527382.png" alt="" />
          <p>
            Якщо ж ми зробимо два збереження, заснованих на тому самому коміті,
            ми отримаємо розгалужену історію.
          </p>
          <img src="https://media.mate.academy/img4_06b1eb21d5.png" alt="" />
          <p>При злитті гілок ми отримаємо нелінійну історію.</p>
          <img src="https://media.mate.academy/img5_f5698921ea.png" alt="" />
          <p>
            Для того, щоб історія залишалася лінійною, перед злиттям можна
            виконати перебудову гілки:
          </p>
          <pre>git rebase branch_name</pre>
          <p>
            Ця команда дублює відсутні коміти активної гілки, починаючи від
            зазначеної, та переставляє активну гілку на останній із них. У
            нашому прикладі команда git rebase main продублювала коміти з хешами
            aadfbd4 та 2a97e61 після коміту 922eae3, де зараз знаходиться гілка
            main, і перенесла активну гілку feat-42/copy на останній створений
            коміт.
          </p>
          <img src="https://media.mate.academy/img6_baf839e6a2.png" alt="" />
          <p>
            Якщо ми хочемо об'єднати коміти, що перебудовуються, можна виконати
            rebase із ключем -i (інтерактивний):
          </p>
          <pre>
            git rebase -i branch_name
          </pre>
          <img src="https://media.mate.academy/img7_9cb1144078.png" alt="" />
          <p>
            Нижче можеш переглянути всі команди, з якими ми ознайомилися. Слід
            пам'ятати, що всі зміни в історії слід робити до того, як історія
            стала публічною, щоб уникнути конфліктів.
          </p>
          <ul>
            <li>git branch Показати всі гілки</li>
            <li>
              git branch new_branch Створити нову гілку з назвою new_branch
            </li>
            git branch -m new_name Перейменувати поточну гілку на new_name
            <li>git branch -d branch_name Видалити неактивну гілку</li>
            <li>
              git checkout branch_name Перейти з поточної гілки на гілку
              branch_name
            </li>
            <li>
              git switch branch_name Перейти з поточної гілки на гілку
              branch_name
            </li>
            <li>
              git checkout -b new_branch Створити гілку new_branch та одразу
              перейти на неї
            </li>
            <li>
              git switch -c new_branch Створити гілку new_branch та одразу
              перейти на неї
            </li>
            <li>
              git merge branch_name Об'єднати branch_name з поточною гілкою
            </li>
            <li>
              git revert hash_of_commit Створити новий коміт зі змінами
              протилежними змінам у вибраному коміті
            </li>
            <li>
              git reset hash_of_commit Переставити гілку на вказаний коміт
            </li>
            <li>
              git reset HEAD^^ --hard Переставити активну гілку на 2 коміти
              назад та видалити всі зміни в файлах
            </li>
            <li>
              git rebase branch_name Перебудувати зміни з поточної гілки під
              branch_name. Усі коміти поточної гілки будуть перебудовані під
              branch_name
            </li>
            <li>
              git rebase -i branch_name Перебудувати зміни з поточної гілки під
              branch_name. Лише вибрані коміти поточної гілки будуть
              перебудовані під branch_name
            </li>
            <li>
              git restore file_name Видалити непідготовлені зміни до коміту в
              file_name
            </li>
            <li>
              git restore --staged file_name Видалити підготовлені зміни до
              коміту в file_name
            </li>
            <li>
              git restore -SW Видалити всі зміни у файлах (підготовлені та
              непідготовлені до коміту)
            </li>
            <li>git commit --amend Замінити поточний коміт на інший</li>
          </ul>
        </div>
      </div>
    </section>
    <section class="Working-GitHub" id="Git-Hub">
      <div class="container">
        <div class="Working-With-Remote releative__block">
          <h3 class="main-topic-title">Working With Remote Repo (GitHub)</h3>
          <p>
            Для початку, прочитай офіційну документацію
            <a
              href="https://docs.github.com/en/authentication/connecting-to-github-with-ssh"
              >Connecting to GitHub with SSH.</a
            >
            Також впевнись, що перші три кроки з уроку Git Basics уже виконані.
          </p>
          <h4>Крок 1. Перевіряємо SSH-ключ на існування</h4>
          <p>
            Щоб перевірити, чи є в тебе SSH-ключ, відкрий термінал та виконай
            наступну команду:
          </p>
          <pre>
            ls -al ~/.ssh
          </pre>
          <p>
            Ця команда виведе список файлів та каталогів, які знаходяться в
            каталозі ~/.ssh. Також будуть виведені приховані файли, наприклад,
            файли ключів SSH, такі як id_rsa та id_rsa.pub, або інші файли,
            пов'язані з SSH-ключами та налаштуваннями
          </p>
          <p>
            Ось приклад перевірки наявності ключа (твій результат може трошки
            відрізнятися):
          </p>
          <pre>
            <img
              src="https://media.mate.academy/256819649_5d20e95d_f1b9_470c_928f_0fd1644c22de_d61e44d5fb.png"
              alt="picture key  SSH"
            />
            <p>
          </pre>
            На зображенні можна побачити файл SSH-ключа. За замовчуванням його
            назва може бути однією з перелічених:
          </p>
          <pre>
            id_rsa.pub
            id_ecdsa.pub
            id_ed25519.pub
          </pre>
          <p>
            Якщо в тебе немає файлів із такою назвою, тоді потрібно згенерувати новий ключ. Якщо ж ключ уже є, то крок 2 можна пропустити й одразу перейти до кроку 3.
          </p>
          <h4>Крок 2. Генеруємо новий SSH-ключ</h4>
          <p>
            Щоб згенерувати новий ключ, виконай наступну комадну, де <your_email@example.com> заміни на свій емейл:
          </p>
          <pre>
            ssh-keygen -t ed25519 -C "your_email@example.com"
          </pre>
          <p>
            На зображенні ти можеш побачити виконання першої частини генерації ключа. Тут термінал запитує куди потрібно зберегти ключ. Розташування можна змінити, ввівши нове розташування після двох крапок, але ми не рекомендуємо це робити:
          </p>
          <pre>
            <img src="https://media.mate.academy/2_bc8a0fb8ff.png" alt="picture key">
            <p>
          </pre>
            Далі термінал запитує, чи потрібно додати passphrase — парольну фразу. Краще пропустити цей крок і просто натиснути ENTER. Зверни увагу: якщо ти введеш passphrase, то її треба обов'язково запамʼятати. В іншому випадку доведеться створювати ключ заново:
          </p>
          <pre>
            <img src="https://media.mate.academy/3_523cbd408d.png" alt="picture passphrase">
          </pre>
          <p>
            Після підтвердження всіх операцій буде згенеровано ключ. Він буде мати приблизно такий вигляд:
          </p>
          <pre>
            <img src="https://media.mate.academy/4_ff09345a4b.png" alt="type of key">
          </pre>
          <h4>Крок 3. Додаємо SSH-ключ до SSH-агента</h4>
          <p>
            SSH-агент — це програма, яка допомагає керувати приватними ключами SSH та автоматично використовує їх під час спроби з'єднання з віддаленим сервером. Щоб додати ключ до агента, потрібно виконати таку команду:
          </p>
          <pre>eval "$(ssh-agent -s)"</pre>
          <p>
            Ця команда запустить агента SSH та встановить змінні середовища для поточного сеансу оболонки. Якщо команда відпрацює успішно, то ти побачиш наступне:
          </p>
          <pre>
            <img src="https://media.mate.academy/5_8300c5a08f.png" alt="picture ">
          </pre>
          <p>Подальші інструкції відрізняються для Windows та macOS.</p>
          <h4>Windows</h4>
          <p>Якщо ти працюєш на Windows, виконай наступну команду:</p>
          <pre>
            ssh-add ~/.ssh/id_ed25519
          </pre>
          <p>
            <b>
              Далі переходь до кроку 4.
            </b>
          </p>
          <p>
            <b>
              macOS
            </b>
          </p>
          <p>
            У залежності від середовища, яким ти користуєшся, тобі можуть знадобитися такі команди:
          </p>
          <ul>
            <li>sudo -s -H для кореневого доступу перед запуском SSH-агенту;</li>
            <li>exec ssh-agent bash або exec ssh-agent zsh для запуску SSH-агенту.</li>
          </ul>
          <p>
            Якщо ти користуєшся macOS Sierra 10.12.2 або новішою версією, то щоб автоматично завантажувати ключі в SSH-агент і зберігати парольні фрази у зв’язку ключів, потрібно буде змінити файл ~/.ssh/config:
          </p>
          <ol>
            <li>Спочатку перевір чи такий файл існує:
              <pre>
                open ~/.ssh/config
              </pre>
            </li>
          ДАЛЬШЕ НУЖНО ВНЕСТИ ВСЕ ПУНКТЫ ИЗ КОНСПЕКТА.... я пока пропущу и внесу список команд
          </ol>
          ///////////////
          <h4>Корисні команди GIT для роботи з віддаленими репо</h4>
          <ul>
            <li>
              git clone repo_url	Клонує існуюче репо
            </li>
            <li> 
              git remote	Показує список віддалених серверів
            </li>
            <li>
              it remote -v	Показує список віддалених серверів з URL
            </li>
            <li>
              git remote show server_alias	Показує детальну інформацію про сервер
            </li>
            <li>
              git remote add server_alias repo_url	Додає новий псевдонім для сервера з даною repo_url
            </li>
            <li>
              git remote remove server_alias	Від'єднується від сервера
            </li>
            <li>
              git push server_alias branch_name	Відправляє branch_name на server_alias
            </li>
            <li>
              git fetch server_alias branch_name	Завантажує зміни без їх злиття з локальною гілкою
            </li>
            <li>
              git pull server_alias branch_name	Завантажує та зливає зміни
            </li>
          </ul>
        </div>
      </div>
    </section>
    <section class="Useful-links">
      <div class="container">
        <h3 class="main-topic-title">Корисні посилання</h3>
        <hr />
        <p>
          <a href="https://docs.google.com/document/d/1lCt8y3kz62z5dAlMvJ7kQRWouHJRkr991cBHc1bhSbU/edit?tab=t.0">Git & Terminal Recap</a>
        </p>
        <p>
          <a href="https://pages.github.com/">About Github Pages</a>
        </p>
        <p>
          <a href="https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet">Markdown Cheatsheet</a>
        </p>
        <p>
          <a href="https://learngitbranching.js.org/?locale=en">Додаткові завдання</a>
        </p>
    </section>
    <script src="main.js"></script>
  </body>
</html>
