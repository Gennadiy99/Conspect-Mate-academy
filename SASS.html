<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Courses</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap"
      rel="stylesheet"
    />
    <link rel="icon" href="./images/Logo MateAcademy.png" />
    <link rel="stylesheet" href="style/fontello.css" />
    <link rel="stylesheet" href="style/main.css" />
  </head>
  <body>
    <div class="container">
      <section class="nav-bar">
        <div class="nav">
          <a href="index.html">Index</a>
          <a href="Git_and_Terminal.html">Git and Terminal</a>
          <a href="JS_Basics _Extended.html">JS Basics Extended</a>
          <a href="HTML_CSS_Advanced.html">HTML + CSS Advanced</a>
          <a href="BEM.html">BEM</a>
          <a href="SASS.html">SASS</a>
          <a href="Transf and Animations.html">Transform Animations</a>
        </div>
      </section>
      <section class="sass">
        <h1 class="sass main-topic-title">SASS</h1>
        <hr />
        <h3>Налаштування зборки проєкту з препроцесором Sass</h3>
        <p>
          При використанні препроцесора ми пишемо стилі з використанням
          синтаксису, відмінного від CSS. Тому браузер не може напряму
          використовувати такі стилі. З'являється необхідність у компіляції
          стилів з SCSS у CSS. Крім того, під час розробки, ми хочемо, щоб
          сторінка автоматично оновлювалася кожного разу при зміні стилів. Тобто
          нам потрібно, щоб компіляція стилів виконувалася автоматично при зміні
          файлів.
        </p>
        <p>
          Тому, замість розширення Live-server, ми використаємо зборщик
          <a href="https://parceljs.org/getting-started/webapp/">parcel</a>
          . Для цього ми маємо виконати наступні кроки:
        </p>
        <ol>
          <li>
            Запустити npm init -y, щоб створити файл package.json, де будуть
            налаштування нашого проєкту.
          </li>
          <li>Встановити parcel командою npm i -D parcel.</li>
          <li>
            Створити директорію src з файлом index.html, що містить базову
            розмітку.
          </li>
          <li>
            Створити файл ./src/styles.scss і підключити його до index.html
            тегом link:
            <pre>&ltlink rel="stylesheet" href="styles.scss" /> </pre>
          </li>
          <li>
            Для запуску проєкту додати команду "start" в розділі "scripts" файлу
            package.json:
            <pre>"start": "parcel ./src/index.html --open"</pre>
          </li>
          <li>
            Запустити npm start, щоб parcel встановив усі необхідні пакети і
            відкрив сторінку в браузері.
          </li>
        </ol>
        <p>Ось орієнтовний вміст файлу package.json:</p>
        <pre>
          {
            "scripts": {
              "start": "parcel ./src/index.html --open",
              "build": "parcel build --public-url=/dist/"
            },
            "devDependencies": {
              "@parcel/transformer-sass": "^2.12.0",
              "parcel": "^2.12.0"
            }
          }
        </pre>
        <p>
          Схожа конфігурація вже використовується в усіх завданнях, тож для них
          додатково нічого налаштовувати не потрібно.
        </p>
      </section>
      <section class="Intro-to-SASS">
        <h3 class="main-topic-title">Intro-to-SASS / Вступ до Sass</h3>
        <hr />
        <p>
          Коли CSS коду стає багато, підтримувати стилі може стати складно.
          Уникнути дублювань, спростити синтаксис та покращити структуру коду
          допоможе CSS препроцесор.
        </p>
        <p>
          <b>CSS препроцесор</b> — це програма, яка має свій власний синтаксис,
          який потім перетворюється на CSS. Ти пишеш стилі в трохи іншому
          синтаксисі, а потім програма перетворює цей код на звичайний CSS, який
          браузери розуміють. Ми будемо розглядати препроцесор Sass з
          використанням його синтаксису SCSS. Його синтаксис схожий на CSS, але
          має додаткові можливості, які роблять написання стилів зручнішим.
          Популярними альтернативами є Less та Stylus.
        </p>
        <h3>Можливості SCSS</h3>
        <hr />
        <p>
          Синтаксис SCSS є розширенням звичайного CSS, тому почати можна з
          простого перейменування CSS-файлу, і все буде працювати, як і раніше.
          Нижче ми розглянемо приклади коду на SCSS і аналогічний код на CSS для
          кращого розуміння можливостей.
        </p>
        <p>
          <b>Вкладеність та &</b>
        </p>
        <p>Sass дозволяє вкладати селектори один в одного:</p>

        <div style="display: flex">
          <div>
            <pre>
              <p class="descrip-color-pre">SCSS</p>
              .block {
                font-size: 20px;
              
                p {
                  color: red;
                }
              }
            </pre>
          </div>
          <div>
            <pre>
              <p class="descrip-color-pre">CSS</p>
              .block {
                font-size: 20px;
              }
              p {
                  color: red;
                }
            </pre>
          </div>
        </div>
        <p>
          Це дозволяє краще групувати стилі і уникати дублювання селектора, якщо
          ми стилізуємо вкладені елементи. При вкладанні правил одне в одне ми
          можемо використовувати префікс &, який заміняє селектор найближчого
          контейнера.
        </p>
        <p>В цьому випадку фінальний селектор не матиме вкладеності:</p>
        <div style="display: flex">
          <div>
            <pre>
              <p class="descrip-color-pre">SCSS</p>
              .block {
                font-size: 20px;
                
                &__element {
                  color: red;
              
                  &--modifier {
                    color: blue;
                  }
                }
              }
              
            </pre>
          </div>
          <div>
            <pre>
              <p class="descrip-color-pre">CSS</p>
              .block {
                font-size: 20px;
              }
              
              .block__element {
                color: red;
              }
              
              .block__element--modifier {
                color: blue;
              }
              
            </pre>
          </div>
        </div>
        <h3>Вирази</h3>
        <hr />
        <p>
          <b>Sass</b> дозволяє виконувати обчислення з абсолютними значеннями
          <u>(наприклад, px)</u> ще на етапі компіляції. Це дозволяє прибрати
          <b>calc</b> та <b>var</b>, які не залежать від відносних розмірів:
        </p>
        <div style="display: flex">
          <div>
            <pre>
              <p><b><u class="descrip-color-pre">SCSS</u></b></p>
              $screenWidth: 600px;

              .block {
                width: $screenWidth * 2;
                height: calc(#{$screenWidth + 10px} + 10%);
              }
            </pre>
          </div>
          <div>
            <pre>
              <p><b><u class="descrip-color-pre">CSS</u></b></p>
              .block {
                width: 1200px;
                height: calc(610px + 10%);
              }
            </pre>
          </div>
        </div>
      </section>
      <section class="look-and-functions">
        <h3 class="main-topic-title">
          look and functions / внешний вид и Функции
        </h3>
        <hr />
        <h3>Цикли</h3>
        <p>Цикли дозволяють уникнути дублювання коду. Наприклад, цикл @for:</p>

        <div style="display: flex">
          <div>
            <pre>
              <p class="descrip-color-pre">SCSS</p>
              @for $i from 1 through 3 {
                .block-#{$i} {
                  height: 100% / $i;
                }
              }
              
            </pre>
          </div>
          <div>
            <pre>
              <p class="descrip-color-pre">CSS</p>
              .block-1 {
                height: 100%; 
              }
              
              .block-2 {
                height: 50%; 
              }
              
              .block-3 {
                height: 33.3333333333%;
              }
              
            </pre>
          </div>
        </div>
        <p>
          За допомогою циклу @each можна створювати стилі для кожного елемента
          зі списку або кожної пари в map:
        </p>
        <div style="display: flex">
          <div>
            <pre>
              <p class="descrip-color-pre">SCSS</p>
              $colors: (
                'error': #f00,
                'notification': #0f0,
                'success': #00f
              );
              
              @each $name, $color in $colors {
                .message--#{$name} {
                  color: $color;
                }
              }
                       
            </pre>
          </div>
          <div>
            <pre>
              <p class="descrip-color-pre">CSS</p>
              .message--error {
                color: #f00;
              }
              
              .message--notification {
                color: #0f0;
              }
              
              .message--success {
                color: #00f;
              }
                       
            </pre>
          </div>
        </div>
        <h3>Функції</h3>
        <p>Функції дозволяють перевикористовувати логіку обчислень:</p>
        <div style="display: flex">
          <div>
            <pre>
              <p class="descrip-color-pre">SCSS</p>
              $bodyWidth: 600px;

              @function size($width) {
                @return $width / 2;
              }
              
              .container {
                width: size($bodyWidth);
              }
                      
            </pre>
          </div>
          <div>
            <pre>
              <p class="descrip-color-pre">CSS</p>
              .container {
                width: 300px;
              }
              
            </pre>
          </div>
        </div>
        <p>
          Взято из чата GPT подключение Parcel глобально на ПК для всех
          проэктов. Есть минус при командной работе, в случаи разных версий у
          каждого члена команды и своих наборах иструментов могут быть
          проблеммы. Поэтому для работы с командой лучше устанавливать Parcel
          локально к проэкту.
        </p>
        <p>
          Рекомендованный порядок: Установить Parcel: bash Копировать код:
          <b>npm install -g parcel-bundler </b>
          Инициализировать проект: bash Копировать код:
          <b>npm init -y</b>
          Запустить Parcel: bash Копировать код:
          <b>parcel index.html</b>
          Это обеспечит правильную работу Parcel с вашим проектом.
        </p>
        <p><b>Резюме по подключению SCSS к проєкту локально:</b></p>
        <ul>
          <li>npm init -y</li>
          <li>
            <pre>
              <span class="color-gray">изменение в package.json</span>
              "source": "src/index.html",
              "scripts": {
                "start": "parcel --open",
                "build": "parcel build --public-url=/dist/"
              }
            </pre>
            <p>
              В свойстве:"start": "parcel --open", <br />
              start - запускает утилиту , - parcel <br />
              Флаг "--open" - автоматически открывает проэкт в браузере.
            </p>
            <p>
              В свойстве: <b>"build"</b>:
              <i>
                <u>"parcel build --public-url=/dist/"</u>
              </i>
              <br />
              указываем флаг
              <i>
                <u>"--public-url=/dist/"</u>
              </i>
              Где в <u>url</u> добавляем папку <b>/dist/</b> в которой будет
              находится проэкт после сборки утилитой <b>Parcel</b>
            </p>
          </li>
          <li>npm install --save-dev parcel</li>
          <li>npm start</li>
          <li>"ctrl + c" - остановка сборки</li>
          <li>"npm run build" - сборка проэкта в папку "dist"</li>
        </ul>
        <p>
          <b>
            Обращаю внимание, что у картинок или иконок возможно нужно будет
            перепрописать путь на одну папку выше, так как Parcel строит сборку
            от основной папки Style.scss а не от папки относящейся к описанию
            конкретного блока
          </b>
        </p>
      </section>
      <section class="mixin-and-media">
        <h3 class="main-topic-title">
          mixin and media / Миксині и Медиазапросы
        </h3>
        <hr />
        <h3>Міксини</h3>
        <p>
          Міксини дозволяють перевикористовувати набори CSS властивостей або
          правила. Міксин створюється директивою @mixin та підключається за
          допомогою <br />
          <i>@include:</i>
        </p>
        <div style="display: flex">
          <div>
            <pre>
              <p class="descrip-color-pre">SCSS</p>
              @mixin circle($size) {
                height: $size;
                width: $size;
                border-radius: 50%;
              }
              
              .avatar {
                @include circle(50px);
              
                font-size: 16px;
                color: white;
              }
              
            </pre>
          </div>
          <div>
            <pre>
              <p class="descrip-color-pre">CSS</p>
              .avatar {
                height: 50px;
                width: 50px;
                border-radius: 50%;
              
                font-size: 16px;
                color: white;
              }
              
            </pre>
          </div>
        </div>
        <h3>Підключення файлів</h3>
        <p>
          Зазвичай у проєкті є головний файл стилів main.scss або index.scss, до
          якого підключаються усі необхідні файли:
        </p>
        <pre>
          @import './utils/mixins';

          @import './blocks/header';
          @import './blocks/page';
          @import './blocks/footer';

        </pre>
        <p>
          Також можна підключати файли один до одного за допомогою директиви
          @use для використання змінних, функцій та міксинів з одних файлів в
          інших:
        </p>
        <pre>
          <span class="descrip-color-pre">// src/_corners.scss</span>

          $radius: 3px;

          @mixin rounded {
            border-radius: $radius;
          }

        </pre>
        <pre>
          <span class="descrip-color-pre">// style.scss</span>

          @use "src/corners" as c;

          .button {
            @include c.rounded;
            padding: 5px + c.$radius;
          }
      
        </pre>
        <p>
          Більше деталей про можливості Sass можна отримати з
          <a href="https://sass-lang.com/playground/" target="_blank"
            >офіційної документації</a
          >.
        </p>
        <h3>
          Пояснение из 'GPT', разница подключения стилей одного файла к другому
          (в основном Главному scss файлу)
        </h3>
        <p>
          1. <b>Что делает @import?</b> <br />
          @import просто вставляет содержимое одного файла в другой. Он не
          ограничивает доступ к переменным, миксинам или функциям из
          подключаемого файла. То есть, после подключения всё содержимое файла
          становится "глобальным" и доступно в любом другом месте.
        </p>
        <pre>
          <span class="descrip-color-pre">// _icon.scss</span>

          $icon-color: red;

          .icon {
            color: $icon-color;
          }

          <span class="descrip-color-pre">// main.scss</span>

          @import "icon"; <span class="descrip-color-pre">// Вставляет содержимое _icon.scss</span>
          .box {
            background: $icon-color; <span class="descrip-color-pre">// Можно напрямую использовать $icon-color</span>
          }
        </pre>
        <p>
          Проблема @import: Если вы подключаете несколько файлов, содержащих
          одноименные переменные или миксины, они могут конфликтовать
          (перезаписываться).
        </p>
        <p>
          2. <b>Что делает @use?</b> <br />
          @use подключает файл как
          <u>"модуль".</u> Всё, что импортировано из файла, становится
          <u>доступным только через префикс, указанный после as</u> (например,
          c.<b><u>в @use "corners" as c</u></b
          >;).
        </p>
        <p>
          Это: Изолирует пространство имен. Переменные, функции и миксины
          подключаемого файла больше не становятся глобальными. Чтобы
          использовать их, нужно явно указать, из какого модуля они взяты.
          Защищает от конфликтов. Если два файла содержат одинаковую переменную
          <b>$radius</b>, <u>они не перезапишут друг друга</u>, потому что будут
          использоваться как
          <b>
            <u>module1.$radius и module2.$radius.</u>
          </b>
        </p>
        <pre>
          <span class="descrip-color-pre">// _corners.scss</span>
          $radius: 5px;

          @mixin rounded {
            border-radius: $radius;
          }

          <span class="descrip-color-pre">// main.scss</span>
          @use "corners" as c;

          .box {
            @include c.rounded; <span class="descrip-color-pre">// Используем миксин из corners</span>
            padding: 10px + c.$radius; <span class="descrip-color-pre">// Используем переменную из corners</span>
          }
        </pre>
        <p>
          <b>Преимущество @use:</b> <br />
          Даже если вы подключите другой файл с переменной
          <b>$radius</b>, он не повлияет на содержимое модуля corners.
        </p>
        <p>
          3. <b>Ключевое отличие С @import</b><br />
          вы подключаете содержимое файлов целиком. После этого переменные и
          миксины из подключаемого файла "смешиваются" с текущими. <br />
          <b>С @use вы подключаете "инструменты"</b> <br />
          из файла, но всегда обращаетесь к ним <b>через префикс</b>. Это делает
          ваш код модульным и защищённым от конфликтов.
        </p>
        <h3>Важная Особенность подключения файлов scss в главный файл scss</h3>
        <p>
          Когда ты подключаешь файл mixins.scss через @import или @use в главный
          файл (например, style.scss), он становится доступен всем файлам,
          которые тоже подключены в style.scss. Это возможно потому, что SCSS
          компилирует все подключённые файлы в единый.
        </p>
        <h3>Еще есть свойство @forward</h3>
        <p>
          НУЖНО УТОЧНИТЬ ПРИМЕРАМИ С ДОКУМЕНТАЦИИ но внешне работает также как и
          @import но тоько доавляется тоько в SCSS и работает в связке с @use
        </p>
      </section>
      <section class="Useful-links">
        <h3 class="main-topic-title">Корисні посилання</h3>
        <hr />
        <p>
          <a href="https://sass-lang.com/guide/" target="_blank">Sass Basics</a>
        </p>
        <p>
          <a
            href="https://sass-lang.com/documentation/variables/"
            target="_blank"
            >Variables</a
          >
        </p>
        <p>
          <a
            href="https://sass-lang.com/documentation/style-rules/declarations/"
            target="_blank"
            >Property Declarations</a
          >
        </p>
        <p>
          <a
            href="https://sass-lang.com/documentation/style-rules/parent-selector/"
            target="_blank"
            >Parent Selector</a
          >
        </p>
        <p>
          <a
            href="https://sass-lang.com/documentation/interpolation/"
            target="_blank"
            >Interpolation</a
          >
        </p>
        <p>
          <a
            href="https://sass-lang.com/documentation/style-rules/placeholder-selectors/"
            target="_blank"
            >Placeholder Selectors</a
          >
        </p>
        <p>
          <a
            href="https://sass-lang.com/documentation/at-rules/mixin/"
            target="_blank"
            >@mixin and @include</a
          >
        </p>
        <p>
          <a
            href="https://sass-lang.com/documentation/at-rules/control/if/"
            target="_blank"
            >@if and @else</a
          >
        </p>
        <p>
          <a
            href="https://sass-lang.com/documentation/at-rules/control/each/"
            target="_blank"
            >@each</a
          >
        </p>
      </section>
    </div>

    <script src="main.js"></script>
  </body>
</html>
