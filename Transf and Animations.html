<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Courses</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap"
      rel="stylesheet"
    />
    <link rel="icon" href="./images/Logo MateAcademy.png" />
    <link rel="stylesheet" href="style/fontello.css" />
    <link rel="stylesheet" href="style/main.css" />
  </head>

  <body>
    <div class="container">
      <div class="nav">
        <a href="index.html">Index</a>
        <a href="Git_and_Terminal.html">Git and Terminal</a>
        <a href="JS_Basics _Extended.html">JS Basics Extended</a>
        <a href="HTML_CSS_Advanced.html">HTML + CSS Advanced</a>
        <a href="BEM.html">BEM</a>
        <a href="SASS.html">SASS</a>
        <a href="Transf and Animations.html">Transform Animations</a>
      </div>
      <section class="transition">
        <h1 class="main-topic-title">Переходи (transition)</h1>
        <hr />
        <p>
          За замовчуванням, усі стилі змінюються миттєво. Наприклад, якщо
          змінити висоту елемента при наведенні, він буде нібито «стрибати».
          Властивість transition дозволяє зробити це плавно. Наприклад:
        </p>
        <pre>
        .box {
          height: 100px;
          background-color: #f00;
          transition: height 1s;
        }
        
        .box:hover {
          height: 200px;
        }
        
      </pre
        >
        <p>
          Властивість transition є скороченням для окремих властивостей, які
          керують плавністю переходу: transition-property, transition-duration,
          transition-timing-function, transition-delay, де:
        </p>
        <ul>
          <li>
            <b>transition-property</b> дозволяє вказати властивості, які будуть
            змінюватися плавно;
          </li>
          <li>
            <b>transition-duration</b> встановлює, скільки триватиме зміна
            стану;
          </li>
          <li>
            <b>transition-timing-function</b> визначає криву, за якою
            відбуватиметься зміна значення протягом встановленого часу;
          </li>
          <li>
            <b>transition-delay</b> задає час очікування перед початком змін.
          </li>
        </ul>
        <p>Наприклад:</p>
        <pre>
        .box {
          transition: height 4s ease-in-out 1s;
          
          /* is the same as */
          
          transition-property: height;
          transition-duration: 4s;
          transition-timing-function: ease-in-out;
          transition-delay: 1s;
        }
        
      </pre
        >
        <p>
          Якщо додати властивості transition- до елементу в стані :hover, то
          вони застосовуватимуться тільки при наведенні на елемент. Коли ж ми
          приберемо курсор, то ці стилі миттєво зникнуть і плавної зміни не
          відбудеться.
        </p>
      </section>
      <section class="animation">
        <h3 class="main-topic-title">Анімації (animation)</h3>
        <hr />
        <p>
          Ти міг помітити, що часто при завантаженні даних з сервера на сайті
          відображається "спінер" чи індикатор завантаження, щоб користувач
          розумів, що процес триває. Або при наведенні на кнопку “В кошик” в
          інтернет-магазині кнопка може плавно збільшуватися та змінювати колір
          при наведенні, щоб привернути увагу користувача та допомогти йому
          зрозуміти куди натиснути або що робити далі.
        </p>
        <p>
          Все це робиться за допомогою анімації. Анімації не лише дозволяють
          створювати красиві візуальні ефекти, а й відіграють важливу роль в
          покращенні взаємодії користувача з веб-сайтом. Завдяки ним можна
          покращити UX, зробити елементи сайту більш інтерактивними та
          інтуїтивно зрозумілими.<br />
          акож анімації дозволяють змінювати стилі CSS плавно, але, на відміну
          від переходів, дозволяють мати більше, ніж два стани (початковий та
          кінцевий) та повторювати їх кілька разів без будь-яких дій
          користувача. На сучасних сайтах часто використовуються анімовані
          бокові панелі меню або випадаючі списки для більш зрозумілої і плавної
          навігації.<br />
          Анімації дозволяють змінювати стилі CSS плавно, але, на відміну від
          переходів, дозволяють мати більше, ніж два стани (початковий та
          кінцевий) та повторювати їх кілька разів без будь-яких дій
          користувача.<br />
          Щоб створити анімацію, використовуй @keyframes разом з from (0%), to
          (100%) та з одним або кількома проміжними (наприклад, 50%) станами (за
          бажанням):
        </p>
        <pre>
        @keyframes move {
          0% {
            top: 0;
            left: 0;
          }
        
          50% {
            top: 10px;
            left: 10px;
          }
        
          100% {
            top: 50px;
            left: 50px;
          }
        }
        
      </pre
        >
        <p>
          Зверни увагу: у цьому прикладі move — це назва анімації, яку потім
          потрібно вказати в animation-name.
        </p>
        <p>
          Властивість animation є скороченням для animation-duration,
          animation-timing-function, animation-delay, animation-iteration-count,
          animation-direction, animation-fill-mode, animation-name, де:
        </p>
        <ul>
          <li>
            <b>animation-name</b> встановлює назву анімації, надану в
            @keyframes;
          </li>
          <li>
            <b>animation-duration</b> встановлює час, за який закінчиться
            анімація;
          </li>

          <li>
            <b>animation-timing-function</b> встановлює, як анімація
            просувається протягом кожного свого циклу виконання;
          </li>
          <li>
            <b>animation-delay</b> встановлює час очікування перед початком
            анімації;
          </li>
          <li>
            <b>animation-iteration-count</b> встановлює, скільки разів буде
            виконана анімація;
          </li>
          <li>
            <b>animation-direction</b> встановлює напрямок виконання анімації
            (вперед, назад тощо);
          </li>
          <li>
            <b>animation-fill-mode </b>встановлює, як анімація застосовує стилі
            до своєї цілі до та після її виконання.
          </li>
        </ul>
        <p>Наприклад:</p>
        <pre>
        .box {
          animation: move 5s ease 2s 3 reverse;
          
          /* is the same as */ 
          
          animation-name: move;
          animation-duration: 5s;
          animation-timing-function: ease;
          animation-delay: 2s;
          animation-iteration-count: 3;
          animation-direction: reverse;
        }
        
      </pre
        >
        <p>
          Зверни увагу: плавно змінюватися можуть лише CSS-властивості, які
          мають безперервний набір значень (розміри, кольори, прозорість тощо).
          Якщо набір значень фіксований (position, display, visibility...), то
          зміна відбуватиметься миттєво після застосування.
        </p>
        <p>
          Перевірити властивість можна у документі
          <a
            href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_animated_properties"
            >Animatable CSS properties.</a
          >
        </p>
      </section>
      <section class="Transformation">
        <h3 class="main-topic-title">Трансформації (transform)</h3>
        <hr />
        <p>
          Трансформації дозволяють обертати, масштабувати, нахиляти або
          переміщувати елементи.<br />

          Основні функції трансформацій:
        </p>
        <ul>
          <li>
            translate(left, top) зміщує елемент на вказану відстань від його
            початкового положення;
          </li>
          <li>
            rotate(angle) повертає елемент за годинниковою стрілкою на вказаний
            кут;
          </li>
          <li>
            scale(factor) збільшує або зменшує елемент у вказане число разів;
          </li>
          <li>skew(x-angle, y-angle) нахиляє елемент на вказані кути.</li>
        </ul>
        <pre>
        .box {
          transform: translate(50px, 50px);
          transform: rotate(180deg);
          transform: scale(2);
          transform: skew(25deg, 25deg);
        }
        
      </pre
        >
        <p>
          Зверни увагу: трансформації не впливають на сусідні елементи і, так
          само як і позиціоновані, малюються в окремому шарі. Тому вони
          потребують менше перевірок від браузера під час перемальовування, бо
          не впливають на геометрію та кольори інших шарів.
        </p>
      </section>
      <section class="Useful-links">
        <h3 class="main-topic-title">Корисні посилання Transform</h3>
        <hr />
        <p>
          <a
            href="https://www.w3schools.com/css/css3_transitions.asp"
            target="_blank"
            >CSS Transitions</a
          >
        </p>
        <p>
          <a href="https://cubic-bezier.com/#.17,.67,.83,.67" target="_blank"
            >cubic-bezier</a
          >
        </p>
        <p>
          <a
            href="https://www.w3schools.com/css/css3_animations.asp"
            target="_blank"
            >CSS Animations</a
          >
        </p>
        <p>
          <a
            href="https://css-tricks.com/almanac/properties/t/transform/"
            target="_blank"
            >transform</a
          >
        </p>
        <p>
          <a
            href="https://css-tricks.com/almanac/properties/t/transform-origin/"
            target="_blank"
            >transform-origin</a
          >
        </p>
        <p>
          <a
            href="https://www.w3schools.com/css/css3_2dtransforms.asp"
            target="_blank"
            >CSS 2D Transforms</a
          >
        </p>
        <p>
          <a href="https://mate-academy.github.io/animations/" target="_blank"
            >Simple examples</a
          >
        </p>
      </section>
      <section class="grid">
        <h1 class="main-topic-title">Сітки (Grid)</h1>
        <hr />
        <p>
          Сітки дозволяють легко проєктувати макети з рядками та колонками, не
          використовуючи плаваючі <u>(float)</u> елементи та позиціонування.
        </p>
        <p>
          Ми можемо зробити елемент контейнером сітки, встановивши
          <b>display: grid:</b>
        </p>
        <pre>
          .container {
            display: grid;
          }
          
        </pre>
        <h3 class="main-topic-title">Рядки та колонки</h3>
        <hr />
        <p>
          Щоб задати розміри рядків та стовпців сітки, використовуй наступні
          властивості:
        </p>
        <pre>
          .container {
            grid-template-rows: 1fr 2fr 1fr;  
            grid-template-columns: 60px 60px 60px;
          
            /* the shorthand for the `grid-template-rows` and `grid-template-columns` */
            grid-template: 1fr 2fr 1fr / 60px 60px 60px;
          }
          
        </pre>
        <p>
          Одиниця 1fr означає 1 частину вільного місця, що залишається в
          контейнері. Тож 1fr 2fr 1fr означатиме 1/4 2/4 1/4 наявного вільного
          простору.
        </p>
        <p>
          Також можна використовувати значення auto, яке дозволяє визначити
          розмір рядка чи колонки за розміром вмісту.
        </p>
        <p>
          Крім того, існує функція minmax(), яка дозволяє встановити границі для
          розміру колонки чи стовпця. Наприклад:
        </p>
        <pre>
          grid-template-columns: minmax(150px, 25%) 1fr; // ліва колонка займатиме чверть ширини, але не менше 150px

        </pre>
        <p>
          Для уникнення дублювання розмірів можна використовувати функцію
          repeat(), яка дозволяє створити кілька колонок чи рядків однакового
          розміру:
        </p>
        <pre>
          grid-template-columns: repeat(12, 1fr); // 12 однакових колонок

        </pre>
        <p>
          Значення auto-fill та auto-fit дозволяють гнучко адаптувати кількість
          колонок до ширини контейнера, залежно від доступного простору.
        </p>
        <ul>
          <li>
            <b>auto-fill</b> заповнює рядок якомога більшою кількістю колонок,
            що відповідають заданій мінімальній ширині.
          </li>
          <li>
            <b>auto-fit</b> працює схоже, але колонки розтягуються, щоб зайняти
            всю доступну ширину контейнера, коли кількість елементів не вистачає
            для заповнення всіх рядів.
          </li>
        </ul>
        <pre>
          .container {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
          }
          
        </pre>
        <h3 class="main-topic-title">Розміщення Grid-елементів</h3>
        <hr />
        <p>
          Усі прямі дочірні елементи контейнера сітки називаються
          <b>grid items.</b> За замовчуванням вони розміщуються зліва направо і
          зверху вниз по одному в комірку гріда. Це зручно для регулярних сіток,
          таких як товари в інтернет-магазині.
        </p>
        <p>
          Властивість <b>grid-auto-flow</b> контролює, як grid-елементи
          розташовуються у контейнері, коли ми не вказуємо їх розміщення явно.
          Може бути корисною, коли кількість елементів не відома заздалегідь.
        </p>
        <ul>
          <li>
            <b>row</b> (за замовчуванням) — елементи розташовуються по рядках.
          </li>
          <li><b>column</b> — елементи розташовуються по колонках.</li>
          <li>
            <b>dense</b> — автоматично заповнює порожні клітинки, якщо це
            можливо, зберігаючи при цьому загальний порядок елементів.
          </li>
        </ul>
        <p>
          Також <b>Grid</b>-контейнер дозволяє керувати вирівнюванням рядків та
          стовпців за допомогою властивостей <b>align-content</b> та
          <b>justify-content</b>. Вони мають такі ж значення, як і для
          <b>Flexbox</b>.
        </p>
        <p>
          А для вирівнювання елементів всередині рядків та стовпців
          використовують властивості <b>align-items</b> та <b>justify-items.</b>
        </p>
        <p>
          Але іноді потрібно вручну розмістити елементи. Для цього можна
          використати нижченаведені властивості, встановивши
          <b>grid line numbers</b> — лінії між стовпцями або рядками:
        </p>
        <pre>
          .item {
            grid-row-start: 1;
            grid-row-end: 2;
            grid-column-start: 1;
            grid-column-end: 3;
          
            /* the shorthand for the `grid-row-start grid-row-end` */
            grid-row: 1 / 2;
          
            /* the shorthand for the `grid-column-start grid-column-end` */
            grid-column: 1 / 3;
          
            /* the shorthand for the `grid-row-start grid-column-start grid-row-end grid-column-end` */
            grid-area: 1 / 1 / 2 / 3;
          }
          
        </pre>
        <p>
          Також можна надати лініям імена, що робить CSS більш зрозумілим і
          легшим для читання:
        </p>
        <pre>
          .container {
            display: grid;
            grid-template-columns: [start] 1fr [middle] 1fr [end];
          }
          
          .item {
            grid-column: start / end;
          }
          
        </pre>
        <p>
          Простір між рядками та колонками називається gap. Щоб додати його,
          використовуй такі властивості:
        </p>
        <pre>
          .container {
            row-gap: 50px;
            column-gap: 40px;
          
            /* the shorthand for the `row-gap column-gap` */
            gap: 50px 40px;
          }
          
        </pre>
        <h3 class="main-topic-title">
          Застосування grid-area для створення складних макетів
        </h3>
        <hr />
        <p>
          Властивість <b>grid-area</b> дозволяє не тільки вказувати
          місцеположення елемента в сітці, але й використовувати його для
          визначення макетів, які включають декілька рядків та/або колонок. Крім
          того, ви можете використовувати <b>grid-template-areas</b> у
          контейнері для створення "шаблону" макету з іменами областей, що дає
          більше візуального представлення структури макета.
        </p>
        <pre>
          .container {
            display: grid;
            grid-template-areas: 
              "header header header header"
              "title title title sidebar"
              "menu content content sidebar"
              "footer footer footer footer";
          }
          
          .header { grid-area: header; }
          .menu { grid-area: menu; }
          .content { grid-area: content; }
          .sidebar { grid-area: sidebar; }
          .footer { grid-area: footer; }
          
        </pre>
        <h3 class="main-topic-title">Інші можливості</h3>
        <hr />
        <p>
          Це лише декілька прикладів того, як можна використовувати CSS Grid для
          створення складних, але гнучких макетів з легкістю. Ознайомся з
          <a
            href="https://css-tricks.com/snippets/css/complete-guide-grid/"
            target="_blank"
            >A Complete Guide to CSS Grid</a
          >
          , щоб детальніше дізнатися про властивості та використання сіток.
          Також пам'ятай про корисні посилання.
        </p>
        <h3 class="main-topic-title">Дополнительная иформация с Видео урока</h3>
        <hr />
        <p>
          В Грид контейнере указано какое количество строк и колоной будет и с
          какой пропорцией
        </p>
        <pre>
          .container {
            height: 100vh;
            display: grid;
            grid-template-rows: 1fr 1fr 3fr 1fr; 4 строки. 3я занимает место равное 3м строкам
            grid-template-columns: 1fr 2fr 1fr; 3колонки. 2я занимает место равное 2м колонкам
          }
           
        </pre>
        <p>
          А в элементе прописывается сколько линий занимает именно ОН в строке и
          в колонке.
        </p>
        <pre>
          .footer {
            background-color: #257d92;
            grid-row: -2 / -1; - Нумирация линий с конца -2 вторая с конца -1 первая с конца (Строка)
            grid-column: 1 / -1; - Первая линия в начала и последняя с конца (Колонка)
          }
        </pre>
        <h3>ДРУГОЙ МЕТОД УПРАВЛЕНИЯ СЕТКОЙ ГРИД через "Именованную Область.</h3>
        <hr />
        <pre>
          к описанию строк и колонок, 

          grid-template-rows: 1fr 1fr 3fr 1fr;
          grid-template-columns: 1fr 2fr 1fr;
        
          в Грид-контейнере добавляется "Именованная Область"
        </pre>
        <p>
          Именнованые диапазоны, в которых указывается название Области и
          сколько в Строке занимает Колонок эта Область:
        </p>
        <pre>
          grid-template-areas: 
          "header header header" - Область "header" 1 Строка, 3 Колонки
          "sidebar ads ads"      - Область "sidebar" 2 Строка, 1 Колонки
          "sidebar main news"    - Область "main" 1 Строка, 1 Колонки/ "news" 1 Строка, 1 Колонки
          "footer footer footer" - Область "footer" 1 Строка, 3 Колонки
          ;
        </pre>
        <p>
          И теперь обязательно Привязать Элементы к названиям Области, указать в
          каждом элементе свойство:
        </p>
        <pre>
          elem-1 {grid-area: header;}
          elem-2 {grid-area: ads;}
          elem-3 {grid-area: news;}
          elem-4 {grid-area: footer;}
        </pre>
        <p>Пример для контейнера</p>
        <pre>
          .container {
            height: 100vh;
            display: grid;
            grid-template-rows: 1fr 1fr 3fr 1fr;
            grid-template-columns: 1fr 2fr 1fr;
          
            grid-template-areas: 
            "header header header"
            "sidebar ads ads"
            "sidebar main news"
            "footer footer footer"
            ;
          }
        </pre>
        <p>Пример для элемента:</p>
        <pre>
          .header {
            grid-area: header;
            background-color: #235b4a;
          }
        </pre>
        <p>Некоторые практические примеры:</p>
        <pre>
           grid-template-columns: repeat(var(--column-count), 100px); 
          - Колонка равна кол-ву в переменной (1) с разм 100px 

          grid-template-columns: repeat(auto-fit, minmax(100px, 200px) ); 
          - Колонка равна кол-ву которое Указанно и поместится в Контейнер имея разм 100px-200px 

          grid-template-columns: repeat(var(--column-count), minmax(150px, 200px) ); 
          - Колонка равна кол-ву в переменной имея разм 100px до 200px 

          grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
          - Колонка равна кол-ву сколько поместится в Контейнер имея разм 100px до 200px */
        </pre>
        <p>
          Еще один способ установки начала колонки и ряда ВНУТРИ самого элемента
          грид контейнера
        </p>
        <pre>
          .card-1 {
            grid-column: 5 / span 3;
          
          }
          5 - указывает с какой линии сетки начинать строить элемента
          span 3 - указывает сколько промежутков будут включаться в элемент.
        </pre>
      </section>

      <section class="Useful-links">
        <h3 class="main-topic-title">Корисні посилання Grid</h3>
        <hr />
        <p>
          <a
            href="https://css-tricks.com/snippets/css/complete-guide-grid/"
            target="_blank"
            >A Complete Guide to CSS Grid</a
          >
        </p>
        <p>
          <a href="https://cssgridgarden.com/#en" target="_blank"
            >GRID GARDEN (A Grid game)</a
          >
        </p>
        <p>
          <a href="https://www.youtube.com/watch?v=qm0IfG1GyZU" target="_blank"
            >10 modern layouts in 1 line of CSS</a
          >
        </p>
        <ul>
          <li>
            <a href="https://1linelayouts.glitch.me/">1-Line Layouts</a>
          </li>
          <li>
            <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/clamp"
              >clamp()</a
            >
          </li>
          <li>
            <a
              href="https://developer.mozilla.org/en-US/docs/Web/CSS/aspect-ratio#browser_compatibility"
              >aspect-ratio</a
            >
          </li>
        </ul>
        <p>
          <a
            href="https://css-tricks.com/introduction-fr-css-unit/"
            target="_blank"
            >An Introduction to the fr CSS unit</a
          >
        </p>
      </section>
      <section class="Document-and-Events">
        <h1 class="main-topic-title">Document and Events</h1>
        <hr />
        <p>Управление HTML страницей при помощи JS script</p>
        <ul>
          const page = document.querySelector(".page");
          <li>const page - сщздали константу</li>
          <li>document.querySelector - ссылаемся на селектор</li>
          <li>".page" - селектор который попадает в константу</li>
        </ul>
        <ul>
          switcher.addEventListener("click", () => {}
          <li>switcher - константа за которой наблюдаем</li>
          <li>.addEventListener - метод которій наблюдает</li>
          <li>"click" - событие которое отслеживается</li>
          <li>() => {} - функция которая будет выполнена при событии</li>
          <li></li>
        </ul>
        <ul>
          page.classList.contains("page--theme--dark")
          <li>page - константа или переменная</li>
          <li>.classList - метод для работы с классами</li>
          <li>.contains - метод проверяет наличие класса</li>
          <li>("page--theme--dark") - класс который проверяется</li>
          <li>.remove - метод удаляет класс</li>
          <li>.add - метод добавляет класс</li>
        </ul>
        <ul>
          themeName.textContent = "Theme: light";
          <li>themeName - переманная</li>
          <li>.textContent = - метод устанавливает текст в элементе</li>
          <li>"Theme: light" - текс который кстанавливается</li>
        </ul>
        <ul>
          themeName.innerHTML = "Theme:
          <strong>dark</strong
          >";
          <li>themeName - переманная</li>
          <li>.innerHTML = - метод устанавлтивает HTML элемент в элеманте.</li>
          <li>"Theme: &ltstrong> dark &lt/strong>" - текст и тег &ltstrong></li>
        </ul>
        <p>
          Блок кода для создания переключателя на темную и светлую тему
          страницы. Сам принцип переключения это определеняе для страницы
          переменных с цветом Фона и Текста, создание модификатора с
          переопределением цветов этих переменных на противоположные, все это
          через CSS.Через JS происходит переключение, сам контакт пользователя с
          кнопкой, который запускает функцию изменяющуюю изменение цветов
          переменных Фона, Текста а так же написание в теге Текста, - Светлая
          Тема,- Темная тема.
        </p>
        <pre>
          Создание Грид-блока для переключателя световой темы страницы:
          .page__header {
            display: grid;
            grid-template-columns: 1fr 60px;
            padding: 10px;
            color: var(--color-header);
            background-color: var(--bg-header);
            box-shadow: inset 0 -1px 0 #dee2ed;
          
            transition: color 0.3s, bacground-color 0.3s;
          }

        </pre>
        <pre>
          Создание блока переключатель для темы:
          .theme-switcher {
            border-radius: 20px;
            padding: 5px;
            background-color: var(--color-header);
          }
          .theme-switcher::after {
            content: "";
            display: block;
            width: 50%;
            padding-bottom: 50%;
            border-radius: 50%;
            background-color: var(--bg-header);
            transition: transform 0.3s;
          }
          Модификатор смещающий псевдо элемент при изменении темы:
          .theme-switcher--theme--dark::after {
            transform: translateX(100%);
          }
        </pre>
        <pre>
          Сам код JS  который выполняет переключение тем:
          "use strict";
          const page = document.querySelector(".page");
          const switcher = document.querySelector(".theme-switcher");
          const themeName = document.querySelector(".theme-name");
                  
          switcher.addEventListener("click", () => {
            if (page.classList.contains("page--theme--dark")) {
              page.classList.remove("page--theme--dark");
              switcher.classList.remove("theme-switcher--theme--dark");
              themeName.textContent = "Theme: light";
            } else {
              page.classList.add("page--theme--dark");
              switcher.classList.add("theme-switcher--theme--dark");
              themeName.innerHTML = "Theme: &ltstrong> dark &lt/          strong>";
            }
          });
        </pre>
        <h4>
          Обращу внимание на добавление в начало страницы директивы
          <b>"use strict";</b>
        </h4>
        <h3 class="main-topic-title">Custom Dropdown</h3>
        <hr />
        <p>
          Создание Выпадающего списка, по принципу select, но который можно
          стилизовать.
        </p>
        <p>
          Установка для блока "Списка" стилей:<br />
          <ul>
            <li>height: 0; - убирает высоту (блок исчезает)</li>
            <li>overflow: hidden; - Обрезает содержимое блока (которое остается при height: 0;) </li>
          </ul>
        </p>
        <p>
          Создаем селектор
          <code>
            .dropdown--active .dropdown__content {height: auto;}
          </code>
          Который говорит, что при активном списке контент имеет высоту авто, тоесть полную высоту вмещающего весь контент.
        </p>
        <h4><u>'contextmenu'</u> - Событие при нажатии Правой клавиши меню</h4>
        <p>
          <code>trigger.addEventListener("contextmenu", (event) => {
            event.preventDefault();})</code>
            В методе для прослушивания собитий <b>"addEventListener"</b> вторым параметром можно указать обьект <br>
             <b>(event)</b> - "Событие" котрое произошло,<br>
              и есть метод <b>".preventDefault()"</b> - отменяет стандартное поведение события.
        </p>
        <p>
          Можно использовать другой метод <b>".toggle"</b>, который обьединяет в себе использование метод remove / add при проверке наличия класса и переключает стиль.
          <code>dropdown.classList.toggle("dropdown--active");</code>
        </p>
        <p>
          Если установить элементу списка с контентом свойство для плавности появлениея высоты:
          <code>transition: height 0.3s;</code>
          это не сработает так как у установленного модиикатора стоит свойство:
          <code>height: auto;</code> а у него нет числа и браузер не может расчитать плавность. Пэтому плавности появления элемента не получается. Если бы в модификаторе укстановить фиксированное значение высоты: 
          <code>height: 100px;</code> Тогда бы код срабатывал. Значит нам нужно узнать какая будет высота у списка.
        </p>
        <h4>Можно получить переменную последнего выбранного Элемента $0</h4>
        <p>
          Для этого нужно выбрать элемент в браузере, перейти в панель разработчика, выбрать Консоль, и в ней прописать $0 - Это и будет переменная получившая в себя последний выбранный элемент.
        </p>
        <p>
          в панели разработчика можно прописать и выбрать высоту у элемента при помоши свойств:
          $0.clientHeight - внутренняя высота
          208 - значение высоты.
          .scrollHeight - общая прокручиваемая высота
          .offsetHeight - высота элем с падингами + бордерами. 
        </p>
        <p>
          В JS есть свойства <b>"style"</b> - где можно указывать его свойства и значения:<br>
          <code>content.style.height = '0';</code>
        </p>
        <p>
          Что бы получить правильное значение высоты нужно его взять у элемента в расскрытом положении через свойство:<b>clientHeight</b> у элемента <b>"Список"- .dropdown__content</b>
        </p>
        <pre>
          const content = dropdown.querySelector(".dropdown__content");
          - Создаем переменную для списка.
          const initialHeight = content.clientHeight;
          - Получаем значение высоты списка (в раскрытом положении)
          content.style.height = "0";
          - Перед обработчиком собитя ставим высоту "списка" = 0
        </pre>
        <p>
          Для плавности появления списка, нужно использовать в функции полученное значение высоты списка (в развернутом виде)
        </p>
        <pre>
          const initialHeight = content.clientHeight; - переменная с высотой списка.
          content.style.height = `${initialHeight}px`; - код в функции устанавливает для контента высоту из переменной.
        </pre>
        <p>
          Так как скрипт устанавливает высоту строки,<br>
          <code>content.style.height = `${initialHeight}px`;</code> <br>
          и устанавливает элементу класс .dropdown--active <br>
          <code>dropdown.classList.add("dropdown--active");</code> <br>
          Применяется стиль высоты прописанный в css
          <code>height: auto;</code>
        </p>
        <h4>Можно использовать другой подход с использованием анимации свойств </h4>
        <pre>
          .dropdown__content {
            max-height:0;
          }
          .dropdown--active .dropdown__content {
            max-height: 100vh;
          }
          Здесь при получении элементом класса .dropdown--active 
          Элемент получает высоту 100% от видимой высоты экрана. 
        </pre>
        <p>
          Не очент хороший способ, так как выполняется не равномерное открывание элемента и закрывание, при закрывании ожидаем пока закроется видимая высота экранна с самого низа до нашего элемента а потом происходит закрытие всей высоты с нашим элементом. 
        </p>
        <p>Использование свойства scaleY() - маштабирование</p>
        <hr>
        <pre>
          .dropdown__content {
           transform: scaleY(0); 
          }
          .dropdown--active .dropdown__content {
           transform: scaleY(1); 
          }
        </pre>
        <p>
          Все работает, но что бы выполнялась плавность ставим элементу свойство:<br>
        <code>transition: transform 0.3s;</code><br>
        При этом плавность появляется но элемент открывается и исчезает от своей середины.<br>
        Что бы изменить точку раскрытия "списка" добавляем элементу свойство <code>transform-origin: top;</code> <br>
        теперь элемент открывается сверху вниз, но есть маленткий момент, буквы в "списке" перед полным закрытием элемента начинают деформироваться.
      </p>
      <h4>Можно использовать свойства: transform: translateY(-160%);- перемещение по вертикали</h4>
      <p>
        при этом свойстве "список" находится вверху а потом перемещается вниз, создавая илюзию "разворачивания списка сверха" 
      </p>
      <pre>
        .dropdown__content {
          transform: translateY(-160%); 
         }
         .dropdown--active .dropdown__content {
          transform: translateY(0);
         }
      </pre>
      <p>
        но проблемма в том что список перемещается вверх с своего блока через остальные ввер, если список будет в середени страницы, по будет перемещениее через весь контент к началу документа, это не годится
      </p>
      <p>
        Тогда можем применить несколько свойств:<br>
        transform: translateY(-15%);
        opacity: 0; <br>
        Это создаст эект поднятия элемент и исчезновения его, тоесть Илюзию его разворачивания.
      </p>
      <pre>
        .dropdown__content {
          transform: translateY(-15%); 
          opacity: 0;
          transition: 
            transform 0.2s, 
            opacity 0.2s;
          pointer-events: none;

         }
         .dropdown--active .dropdown__content {
          transform: translateY(0);
          opacity: 1;
          pointer-events: auto;
         }
      </pre>
      <p>
        В этом варианте все работает хорошо, и для того что бы изначально скрыты "список" который поднят вверх не перекрывал возможность клика на кнопку, добавляется свойство <br>
        <code>pointer-events: none;</code><br>
        А после клика,- 
        <code>pointer-events: auto;</code>
      </p>
      <h3 class="main-topic-title">Adding And Removing Elements</h3>
      <hr>
      </section>
    </div>
  </body>
</html>
