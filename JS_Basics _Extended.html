<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Style code</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap"
      rel="stylesheet"
    />
    <link rel="icon" href="./images/Logo MateAcademy.png" />
    <link rel="stylesheet" href="style/fontello.css" />
    <link rel="stylesheet" href="style/main.css" />
  </head>
  <body>
    <section class="nav-bar">
      <div class="nav">
        <a href="index.html">Index</a>
        <a href="Git_and_Terminal.html">Git and Terminal</a>
        <a href="JS_Basics _Extended.html">JS Basics Extended</a>
        <a href="contacts.html">Contact</a>
      </div>
    </section>
    <div class="container">
      <section class="style-code">
        <h1 class="main-topic-title">Style code</h1>
        <h3>Стиль коду</h3>
        <p>
          Хороша програма має не тільки правильно працювати, але й бути
          зрозумілою, щоб її легко було покращувати та виправляти помилки за
          потреби. Дуже важливо при цьому дотримуватись певних правил написання
          коду. Вони можуть бути різними на різних проєктах. Ось правила, які ми
          використовуємо в Mate academy. Загальні рекомендації Код завжди має
          бути зрозумілим. Скорочувати код варто, тільки якщо це його не
          ускладнює. Коментарі пишемо, щоб пояснити, чому прийнято таке рішення,
          а не як це працює (це має бути ясно з коду). Видаляємо зайвий код (не
          залишаємо закоментованого).
        </p>
        <h3>Команди</h3>
        <p>
          Кожну команду ми пишемо з нового рядка, щоб легше було знайти її межі.
          Щоб уникнути неочевидності в коді, наприкінці кожної команди ставимо
          ;. Рядок не повинен бути довшим за 80 символів, щоб програму було
          зручно читати.
        </p>
        <h3>Змінні</h3>
        <p>
          Змінні ми оголошуємо за допомогою let або const, але не var (старий
          спосіб).
        </p>
        <p>Кожну змінну оголошуємо окремим let або const:</p>
        <pre>
          // good
          let x = 1;
          let y = 2;
        </pre>
        <pre>
          // bad
          let x = 1, y = 2;
        </pre>
        <p>
          Назви змінних та функцій пишемо в camelCase (без _ і всі слова, окрім
          першого, пишуться з великої літери):
        </p>
        <pre>
          // good
          let userName = '';
        </pre>
        <pre>
          // bad
          let user_name = '';
          let UserName = ''; // can be used in some situations
        </pre>
        <ul>
          <li>
            Однолітерні змінні допустимі лише там, де очевидне їх значення:
            <ul>
              <li>індекс у циклі;</li>
              <li>для математичних змінних (x, y, a, b, c);</li>
              <li>
                якщо це значно скорочує та спрощує код і робить його більш
                зрозумілим.
              </li>
            </ul>
          </li>
          <li>Тільки англійська мова, жодних транслітерацій.</li>
          <li>Назви змінних мають пояснювати, що в них зберігається.</li>
          <li>
            Для булевих значень використовуємо дієслова у 3-й формі, пасивний
            стан або модальні дієслова (isLoaded, loaded, hasEnoughMoney,
            canBuy)
          </li>
          <li>Для масивів — іменники в множині.</li>
          <li>
            Не використовуємо суфікси та приставки arr, obj і подібні — назва
            повинна бути зрозумілою і без них.
          </li>
          <li>
            Назва функції має починатися з дієслова та описувати, що вона
            робить. Виняток: обробники подій можуть називатися, наприклад,
            onClick або submitHandler (буде обговорено пізніше).
          </li>
        </ul>
        <h3>Приклади поганих назв</h3>
        <ul>
          <li>
            Абстрактні назви змінних та функцій (obj, data, value, item, elem
            тощо), коли можна підібрати більш слушні.
          </li>
          <li>
            Схожі імена змінних (num1 та num2), оскільки легко зробити
            друкарську помилку.
          </li>
          <li>
            Повторне використання змінних та параметрів для нових значень,
            оскільки при читанні незрозуміло, що там зберігається зараз.
          </li>
          <li>
            Функція не робить те, що написано в її назві або робить ще щось,
            крім того, що вказано в назві (побічний ефект)
          </li>
        </ul>
        <h3>Блоки</h3>
        <ul>
          <li>
            Тіло циклу, функції, блоки if ми завжди обгортаємо в {}:
            <pre>
              // good
              if (condition) {
                result += 123;
              }
              for (let i = 0; i < text.length; i++) {
                result = text[i] + result;
              }
            </pre>
            <pre>
              // bad
              if (condition) result += 123;;
              for (let i = 0; i < text.length; i++)
                result = text[i] + result;
            </pre>
          </li>
          <li>
            Відкриваючу { ставимо на тому ж рядку, де почалася конструкція.
          </li>
          <li>
            Закриваючу } ставимо на наступному рядку після останньої команди
            блоку:
          </li>
          <pre>
            // good
            if (condition) {
              result = 123;
            } else {
              result = 456;
            }
            function sum(a, b) {
              return a + b;
            }
          </pre>
          <pre>
            // bad
            if (condition) { result = 123; }
            else { result = 456; }
            function sum(a, b)
            {
              return a + b;
            }
          </pre>
        </ul>
        <h3>Відступи</h3>
        <ul>
          <li>
            Вкладений код повинен мати відступ на 2 пробіли більше, ніж
            зовнішній:
            <pre>
              // good
              if (condition) {
                console.log(456);
                console.log(123);
              }
            </pre>
            <pre>
              // bad
              if (condition) {
                  console.log(456)
              console.log(123)
              }
            </pre>
          </li>
          <li>
            Ми відокремлюємо смислові блоки один від одного порожнім рядком,
            коли вони стоять поряд (на одному рівні вкладеності). До таких
            блоків відносяться функції, цикли, if, return, блок змінних та групи
            пов'язаних команд:
            <pre>
              // good
              function test() {
                let x = 10;
                while (x > 5) {
                  x--;
                  console.log(x);
                }
                return x;
              }
            </pre>
            <pre>
              // bad
              function test() {
                let x = 10;
                while (x > 5) {
                  x--;
                  console.log(x);
                }
                return x;
              }
            </pre>
          </li>
        </ul>
        <h3>JSDoc</h3>
        <p>
          Починаючи з цього урока, для покращення автодоповнення, ми будемо
          додавати до кожної функції коментарі в форматі JSDoc:
        </p>
        <pre>
          /**
          * @param {number} a
          * @param {number} b
          *
          * @returns {string}
          */
          function getSumText(a, b) {
            return `${a} + ${b} = ${a + b}`;
          }
        </pre>
        <p>
          Коментар @param {type} name дозволяє підказати редактору, що параметр
          з ім'ям name має тип, вказаний в {}. Це може бути number, string,
          boolean, null, undefined для примітивних значень, або number[] для
          масиву чисел, string[] для масиву рядків, тощо.
        </p>
        <p>
          Також в {} можна записати два чи більше типів через |, тоді параметр
          має бути одного з цих типів. Наприклад:
        </p>
        <pre>
          /**
          * @param {number|string} id
          */
          function check(id) {}
        </pre>
        <p>
          Аналогічно, тип, що стоїть після @returns {type}, підказує тип
          значення, яке має повертати функція.
        </p>
        <h3>Умовний (тернарний) оператор</h3>
        <p>
          Іноді необхідно записати різні значення в змінну залежно від умови. Це
          можна зробити за допомогою if та else:
        </p>
        <pre>
          let age = 23;
          let result = '';
          // умова
          if (age >= 18) {
            // значення1
            result = 'Дорослий';
          } else {
            // значення2
            result = 'Не дорослий';
          }
          console.log(result); // 'Дорослий'
        </pre>
        <p>Але це не дуже зручно з двох причин:</p>
        <ol>
          <li>Занадто велика конструкція.</li>
          <li>
            Ми не зможемо використати const для змінної result, тому що нам
            потрібно записати в неї нове значення всередині if else.
          </li>
        </ol>
        <p>
          Є коротший та зручніший варіант запису — умовний (тернарний) оператор.
          Розглянемо приклад:
        </p>
        <pre>
          let age = 23;
          const result = age >= 18 ? 'Дорослий' : 'Не дорослий';
          console.log(result); // 'Дорослий'
        </pre>
        <p>
          Якщо умова age >= 18 виконалася (як у нашому прикладі), то буде обрано
          те, що стоїть після ? ('Дорослий'), інакше — те, що стоїть після :
          ('Не дорослий').
        </p>
        <p>Для наочності, вираз в умові можна взяти в дужки:</p>
        <pre>
          const result = (age >= 18) ? 'Дорослий' : 'Не дорослий';
        </pre>
        <p>Якщо вираз довгий, то можна переносити значення на нові рядки:</p>
        <pre>
          const result = (age >= 18)
          ? 'Дорослий'
          : 'Не дорослий';
        </pre>
        <p>
          Цей оператор часто називають тернарним, оскільки це єдиний оператор, у
          якому використовуються 3 частини.
        </p>
      </section>
      <section class="Useful-links">
        <p>Корисні посилання</p>
        <hr />
        <p>
          <a
            href="https://doc.clickup.com/24383048/p/h/q83j8-478895/5c8e6ac12123a17"
            >Комбінації клавіш VSCode</a
          >
        </p>
        <p>
          <a
            href="https://doc.clickup.com/24383048/p/h/q83j8-478955/72cf30d21cab1bc"
            >Словничок термінів</a
          >
        </p>
        <p>
          <a href="https://javascript.info/coding-style">Coding Style</a>
        </p>
        <p>
          <a href="https://javascript.info/strict-mode"
            >The modern mode, "use strict"</a
          >
        </p>
        <p>
          <a href="https://javascript.info/ninja-code"
            >Ninja code (bad code style examples)</a
          >
        </p>
      </section>
      <section class="Working-With-Numbers">
        <h1 class="main-topic-title">Работа с числами</h1>
        <hr />
        <p>
          Як розробники програмного забезпечення, ми повинні виконувати типові
          операції з числами: округлення їх, перетворення введення користувача в
          числа, генерацію випадкових чисел тощо. У цій темі ми практикуємося у
          виконанні цих рутинних завдань.
        </p>
        <h3>Числові літерали</h3>
        <hr />
        <p>
          У JavaScript числа бувають цілі та з дробовою частиною. Для запису
          чисел використовуються літерали (від англ. «literally» — буквально)
        </p>
        <p>
          Залежно від системи числення, існують різні способи запису числа. Для
          прикладу, візьмемо десяткове число 123 та запишемо його в різних
          системах:
        </p>
        <pre>
          let dec = 123; // 10-кова система
          let hex = 0x7b; // `0x` — префікс 16-кової системи.           Саме число — `7b`
          let bin = 0b1111011; // `0b` — префікс 2-кової системи.           Саме число — `1111011`
          let oct = 0o173; // `0o` — префікс 8-кової системи.           Саме число — `173`
        </pre>
        <p>
          Найчастіше ми будемо працювати з десятковими числами. Їх теж можна
          записати кількома способами:
        </p>
        <pre>
          let x = 15; // ціле десяткове число
          let y = 0.52; // число з дробовою частиною
          let z = 3.14e6; // `e6` означає помножити на `10` в `6`           степені, тобто наше число – `3140000` 
        </pre>
        <h3>Бінарні та шістнадцяткові числа</h3>
        <hr />
        <p>
          Звична нам десяткова система є позиційною, тому кожна цифра множиться
          на 10 у відповідному степені (позиція від правого краю, рахуючи з 0).
          Розглянемо число 345:
        </p>
        <pre>
          345 === 3 * (10 ** 2) + 4 * (10 ** 1) + 5 * (10 ** 0)
          345 === (3 * 100) + (4 * 10) + (5 * 1)
        </pre>
        <p>
          У двійковій системі є лише цифри 0 та 1, які треба множити на 2 у
          відповідному степені:
        </p>
        <pre>
          0b101101 === 1 * (2 ** 5) + 0 * (2 ** 4) + 1 * (2 ** 3) + 1 * (2 ** 2) + 0 * (2 ** 1) + 1 * (2 ** 0)
          0b101101 === (1 * 32) + (0 * 16) + (1 * 8) + (1 * 4) + (0 * 2) + (1 * 1)
          0b101101 === 32 + 8 + 4 + 1 === 45
        </pre>
        <p>
          У шістнадцятковій системі використовуються цифри від 0 до 9 і літери A
          = 10, B = 11, C = 12, D = 13, E = 14 та F = 15:
        </p>
        <pre>
          0x9F2C = 9 * (16 ** 3) + 15 * (16 ** 2) + 2 * (16 ** 1) + 12 * (16 ** 0)
          0x9F2C = (9 * 4096) + (15 * 256) + (2 * 16) + (12 * 1)
          0x9F2C = 36864 + 3840 + 32 + 12 === 40748
        </pre>
        <h3>Округлення значень</h3>
        <hr />
        <p>
          Дуже часто в процесі обчислень у тебе будуть виходити не цілі числа, а
          дробові. Їх можна округлити:
        </p>
        <ul>
          <li>
            <b>Math.round(x)</b> — округляє x до найближчого цілого (вгору або
            вниз):
            <pre>
              console.log(
                Math.round(10.1), // 10
                Math.round(10.5), // 11
                Math.round(10.8), // 11
                Math.round(-10.1), // -10
                Math.round(-10.5), // -10
                Math.round(-10.8), // -11
              );
            </pre>
          </li>
          <li>
            <b>Math.floor(x) </b>— округляє x вниз (до найближчого меншого
            цілого):
            <pre>
              console.log(
                Math.floor(10.1), // 10
                Math.floor(10.5), // 10
                Math.floor(10.8), // 10
                Math.floor(-10.1), // -11
                Math.floor(-10.5), // -11
                Math.floor(-10.8), // -11
              );
            </pre>
          </li>
          <li>
            <b>Math.ceil(x)</b> — округляє x вгору (до найближчого більшого
            цілого):
            <pre>
              console.log(
                Math.ceil(10.1), // 11
                Math.ceil(10.5), // 11
                Math.ceil(10.8), // 11
                Math.ceil(-10.1), // -10
                Math.ceil(-10.5), // -10
                Math.ceil(-10.8), // -10
              );
            </pre>
          </li>
          <li>
            <b>Math.trunc(x)</b> — відкидає дробову частину:
            <pre>
              console.log(
              Math.trunc(10.1), // 10
              Math.trunc(10.5), // 10
              Math.trunc(10.8), // 10
              Math.trunc(-10.1), // -10
              Math.trunc(-10.5), // -10
              Math.trunc(-10.8), // -10
            );
            </pre>
          </li>
          <li>
            x.toFixed(numberOfDigits) перетворює число на рядок із заданою
            кількістю цифр після коми:
            <pre>
              console.log(
              (3.14159).toFixed(0), // '3'
              (3.14159).toFixed(2), // '3.14'
              (3.14159).toFixed(3), // '3.142'
              (3.14159).toFixed(4), // '3.1416'
              (3.14).toFixed(4), // '3.1400'
              (3).toFixed(4), // '3.0000'
              (-3.14159).toFixed(4), // '-3.1416'
            );
            </pre>
          </li>
        </ul>
        <h3>Перетворення рядка на число</h3>
        <hr />
        <p>
          При отриманні даних введених користувачем, числа можуть бути записані
          як рядки що місять цифри. Звісно в програмі нам потрібно перетворити
          такий "числовий" рядок на число. Для цього існує декілька способів.
        </p>
        <p>Для строгого перетворення зазвичай використовують оператор +:</p>
        <pre>
          const text = '3.14159';

          console.log(
            +text, // 3.14159
            +'27.5', // 27.5
            +'2.4e3', // 2400 - експоненційний формат
            +'0xABC', // 2748 - шістнадцяткове число
            +'0b1001', // 9 - бінарне число
          );
        </pre>
        <p>Аналогічним чином працює стандартна функція Number:</p>
        <pre>
          console.log(
            Number(text), // 3.14159
            Number('27.5'), // 27.5
            Number('2.4e3'), // 2400 - експоненційний формат
            Number('0xABC'), // 2748 - шістнадцяткове число
            Number('0b1001'), // 9 - бінарне число
          );
        </pre>
        <p>Також на число можна перетворити значення інших типів:</p>
        <pre>
          console.log(+true); // 1
            console.log(+false); // 0
            console.log(+null); // 0 
            console.log(+undefined); // NaN 
        </pre>
        <p>
          Якщо повне перетворення рядка на число неможливе, то результатом
          перетворення буде значення NaN:
        </p>
        <pre>
          const text = 'Hello';

          console.log(
            +text, // NaN - текст не є числом
            +'35$', // NaN - $ не є валідним символом числа
            +'2.4.3', // NaN - друга десяткова . не допускається
            +'0xABCZ', // NaN - Z не є валідним символом у 16-вій системі
            +'0b10012', // NaN - 2 не є валідним символом у 2-вій системі
          );
        </pre>
        <p>
          Для часткового перетворення числового рядка використовуються
          стандартні функції parseInt та parseFloat.
        </p>
        <p>
          <b>parseInt</b> приймає два параметри: значення для перетворення та
          систему числення (опціонально), і повертає ціле число, або NaN, якщо
          рядок не починається з числа:
        </p>
        <pre>
          parseInt('256$'); // 256 - зупиняємось на першому символі, що не є частиною цілого числа
          parseInt('123.456'); // 123 - дробова частина відкидається
          parseInt('256', 2); // NaN - бо такі цифри не існують в двійковій системі
          parseInt('1A'); // 1 - літера `А` ігнорується
          parseInt('1A', 16); // 26 — шістнадцяткове число
          parseInt('abc'); // NaN - рядок не починається з числа в 10-вій системі
        </pre>
        <p>
          <b>parseFloat</b> приймає значення для перетворення і число або NaN,
          якщо конвертація неможлива, наприклад:
        </p>
        <pre>
          parseFloat('3.14'); // 3.14
          parseFloat('2.718 is the base of natural logarithm'); // 2.718
          parseFloat('abc'); // NaN, бо рядок не починається з числа
        </pre>
        <h3>Infinity та NaN</h3>
        <hr />
        <p>
          В JavaScript існує 2 спеціальних числових значення: Infinity та NaN.
        </p>
        <p>
          <b>Infinity</b> — це математична безкінечність. Вона виникає при
          діленні на 0 і є більшою за будь-яке число. Також є -Infinity — вона
          менша за будь-яке число.
        </p>
        <p>
          <b>Функція isFinite()</b> перетворює аргумент у число та повертає
          true, якщо це звичайне число, а не <b>NaN чи Infinity</b>.
        </p>
        <p>
          <b>NaN</b> — це спеціальне числове значення, яке виникає при помилці
          обчислення. Наприклад, якщо 0 поділити на 0, або число на рядок, який
          не може бути приведений до числа (346 / 'apple'). Значення NaN
          унікальне тим, що воно не дорівнює нічому іншому, навіть самому собі:
        </p>
        <pre>
          console.log(NaN === NaN); // false
        </pre>
        <p>
          Також існує <b>функція isNaN</b>, яка перетворює свій аргумент на
          число і визначає, чи є воно NaN (не числом) чи ні:
        </p>
        <pre>
          isNaN(NaN); // true
          isNaN(45.2); // false
          isNaN(Infinity); // false
          isNaN('123'); // false
          isNaN('0x123'); // false
          isNaN('12 hello'); // true
        </pre>
        <h3>Генерація випадкового числа</h3>
        <hr />
        <p>
          <b>Метод Math.random</b> повертає випадкове число від 0 (включно) до 1
          (не включно):
        </p>
        <pre>
          console.log(
            Math.random(), // 0.6460395007021751
            Math.random(), // 0.511311069945108
            Math.random(), // 0.36258333704200685
          );
        </pre>
        <p>
          Для генерації випадкових цілих чисел від 0 до n треба помножити
          результат на n + 1 та округлити вниз (до меншого цілого):
        </p>
        <pre>
          Math.floor(Math.random() * 11); // випадкове ціле число від 0 до 10 включно
        </pre>
        <p>
          Якщо потрібно випадкове ціле число від min до max включно, то
          генерують число від 0 до max - min і додають min
        </p>
        <pre>
          Math.floor(Math.random() * (max - min + 1)) + min;
          Math.floor(Math.random() * (11 - 7 + 1)) + 7; // випадкове ціле число від 7 до 11 включно
          Math.floor(Math.random() * (20 - 10 + 1)) + 10; // випадкове ціле число від 10 до 20 включно
        </pre>
      </section>
      <section class="Useful-links">
        <p>Корисні посилання</p>
        <hr />
        <p>
          <a
            href="https://developer.mozilla.org/ru/docs/Learn/JavaScript/First_steps/Math"
            >Basic Math in JS</a
          >
        </p>
        <p>
          <a
            href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/parseInt"
            >parseInt()</a
          >
        </p>
        <p>
          <a
            href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/parseFloat"
            >parseFloat()</a
          >
        </p>
      </section>
      <section class="Loops_in_Details">
        <h1 class="main-topic-title"></h1>
        <hr />
        <h3>Цикли в деталях</h3>
        <p>У цьому уроці ми розглянемо цикли більш детально.</p>
        <p class="b">debugger</p>
        <p>
          Доволі часто код може працювати не так, як ми очікуємо. Щоб
          розібратися чому, можна використовувати console.log, друкуючи значення
          змінних чи текстові повідомлення.
        </p>
        <p>
          Але в браузері є можливість зупинити виконання програми і продовжити
          його покроково. Для цього в код можна додати команду debugger. Після
          цього треба відкрити в браузері Developer Tools кнопкою F12 і
          перезавантажити сторінку.
        </p>
        <img
          src="https://media.mate.academy/debugger_b5bf7fc024.png"
          alt="picture"
        />
        <p>
          Програма зупиниться на рядку з командою debugger і буде чекати на
          подальші інструкції. Праворуч в розділі Scope можна побачити значення
          змінних.
        </p>
        <p>
          Для продовження виконання можна використати кнопки зі стрілками вгорі
          або клавіші:
        </p>
        <ul>
          <li>F10 щоб перейти до наступної команди</li>
          <li>F11 щоб зайти в функцію</li>
          <li>Shift+F11 щоб вийти з функції</li>
          <li>
            F8 щоб виконати всі команди до наступного debugger або до кінця
            програми
          </li>
        </ul>
        <p>
          Ми дуже радимо написати простий цикл for (як на скріншоті) та виконати
          його покроково, щоб краще зрозуміти, як він працює.
        </p>
      </section>
      <section class="Infinit_Loop_break_and_continue">
        <h1 class="main-topic-title">Безкінечний цикл</h1>
        <hr>
        <p>
          Безкінечним називається такий цикл, умова якого завжди вірна (наприклад, true). Це означає, що тіло циклу буде виконуватись вічно. Такий цикл може виконуватись доти, доки працює комп'ютер користувача. Більшість браузерів можуть це виявити та запропонують зупинити виконання такого скрипту.
        </p>
        <p>Приклад безкінечного циклу:</p>
        <p>
          <b>ВНЕСТИ ВСЮ ТЕОРИЮ ИЗ ЭТОГО РАЗДЕЛА</b>
        </p>
      </section>
    </div>

    <script src="main.js"></script>
  </body>
</html>
