<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Style code</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap"
      rel="stylesheet"
    />
    <link rel="icon" href="./images/Logo MateAcademy.png" />
    <link rel="stylesheet" href="style/fontello.css" />
    <link rel="stylesheet" href="style/main.css" />
  </head>
  <body>
    <section class="nav-bar">
      <div class="nav">
        <a href="index.html">Index</a>
        <a href="Git_and_Terminal.html">Git and Terminal</a>
        <a href="JS_Basics _Extended.html">JS Basics Extended</a>
        <a href="contacts.html">Contact</a>
      </div>
    </section>
    <div class="container">
      <section class="style-code">
        <h1 class="main-topic-title">Style code</h1>
        <h3>Стиль коду</h3>
        <p>
          Хороша програма має не тільки правильно працювати, але й бути
          зрозумілою, щоб її легко було покращувати та виправляти помилки за
          потреби. Дуже важливо при цьому дотримуватись певних правил написання
          коду. Вони можуть бути різними на різних проєктах. Ось правила, які ми
          використовуємо в Mate academy. Загальні рекомендації Код завжди має
          бути зрозумілим. Скорочувати код варто, тільки якщо це його не
          ускладнює. Коментарі пишемо, щоб пояснити, чому прийнято таке рішення,
          а не як це працює (це має бути ясно з коду). Видаляємо зайвий код (не
          залишаємо закоментованого).
        </p>
        <h3>Команди</h3>
        <p>
          Кожну команду ми пишемо з нового рядка, щоб легше було знайти її межі.
          Щоб уникнути неочевидності в коді, наприкінці кожної команди ставимо
          ;. Рядок не повинен бути довшим за 80 символів, щоб програму було
          зручно читати.
        </p>
        <h3>Змінні</h3>
        <p>
          Змінні ми оголошуємо за допомогою let або const, але не var (старий
          спосіб).
        </p>
        <p>Кожну змінну оголошуємо окремим let або const:</p>
        <pre>
          // good
          let x = 1;
          let y = 2;
        </pre>
        <pre>
          // bad
          let x = 1, y = 2;
        </pre>
        <p>
          Назви змінних та функцій пишемо в camelCase (без _ і всі слова, окрім
          першого, пишуться з великої літери):
        </p>
        <pre>
          // good
          let userName = '';
        </pre>
        <pre>
          // bad
          let user_name = '';
          let UserName = ''; // can be used in some situations
        </pre>
        <ul>
          <li>
            Однолітерні змінні допустимі лише там, де очевидне їх значення:
            <ul>
              <li>індекс у циклі;</li>
              <li>для математичних змінних (x, y, a, b, c);</li>
              <li>
                якщо це значно скорочує та спрощує код і робить його більш
                зрозумілим.
              </li>
            </ul>
          </li>
          <li>Тільки англійська мова, жодних транслітерацій.</li>
          <li>Назви змінних мають пояснювати, що в них зберігається.</li>
          <li>
            Для булевих значень використовуємо дієслова у 3-й формі, пасивний
            стан або модальні дієслова (isLoaded, loaded, hasEnoughMoney,
            canBuy)
          </li>
          <li>Для масивів — іменники в множині.</li>
          <li>
            Не використовуємо суфікси та приставки arr, obj і подібні — назва
            повинна бути зрозумілою і без них.
          </li>
          <li>
            Назва функції має починатися з дієслова та описувати, що вона
            робить. Виняток: обробники подій можуть називатися, наприклад,
            onClick або submitHandler (буде обговорено пізніше).
          </li>
        </ul>
        <h3>Приклади поганих назв</h3>
        <ul>
          <li>
            Абстрактні назви змінних та функцій (obj, data, value, item, elem
            тощо), коли можна підібрати більш слушні.
          </li>
          <li>
            Схожі імена змінних (num1 та num2), оскільки легко зробити
            друкарську помилку.
          </li>
          <li>
            Повторне використання змінних та параметрів для нових значень,
            оскільки при читанні незрозуміло, що там зберігається зараз.
          </li>
          <li>
            Функція не робить те, що написано в її назві або робить ще щось,
            крім того, що вказано в назві (побічний ефект)
          </li>
        </ul>
        <h3>Блоки</h3>
        <ul>
          <li>
            Тіло циклу, функції, блоки if ми завжди обгортаємо в {}:
            <pre>
              // good
              if (condition) {
                result += 123;
              }
              for (let i = 0; i < text.length; i++) {
                result = text[i] + result;
              }
            </pre>
            <pre>
              // bad
              if (condition) result += 123;;
              for (let i = 0; i < text.length; i++)
                result = text[i] + result;
            </pre>
          </li>
          <li>
            Відкриваючу { ставимо на тому ж рядку, де почалася конструкція.
          </li>
          <li>
            Закриваючу } ставимо на наступному рядку після останньої команди
            блоку:
          </li>
          <pre>
            // good
            if (condition) {
              result = 123;
            } else {
              result = 456;
            }
            function sum(a, b) {
              return a + b;
            }
          </pre>
          <pre>
            // bad
            if (condition) { result = 123; }
            else { result = 456; }
            function sum(a, b)
            {
              return a + b;
            }
          </pre>
        </ul>
        <h3>Відступи</h3>
        <ul>
          <li>
            Вкладений код повинен мати відступ на 2 пробіли більше, ніж
            зовнішній:
            <pre>
              // good
              if (condition) {
                console.log(456);
                console.log(123);
              }
            </pre>
            <pre>
              // bad
              if (condition) {
                  console.log(456)
              console.log(123)
              }
            </pre>
          </li>
          <li>
            Ми відокремлюємо смислові блоки один від одного порожнім рядком,
            коли вони стоять поряд (на одному рівні вкладеності). До таких
            блоків відносяться функції, цикли, if, return, блок змінних та групи
            пов'язаних команд:
            <pre>
              // good
              function test() {
                let x = 10;
                while (x > 5) {
                  x--;
                  console.log(x);
                }
                return x;
              }
            </pre>
            <pre>
              // bad
              function test() {
                let x = 10;
                while (x > 5) {
                  x--;
                  console.log(x);
                }
                return x;
              }
            </pre>
          </li>
        </ul>
        <h3>JSDoc</h3>
        <p>
          Починаючи з цього урока, для покращення автодоповнення, ми будемо
          додавати до кожної функції коментарі в форматі JSDoc:
        </p>
        <pre>
          /**
          * @param {number} a
          * @param {number} b
          *
          * @returns {string}
          */
          function getSumText(a, b) {
            return `${a} + ${b} = ${a + b}`;
          }
        </pre>
        <p>
          Коментар @param {type} name дозволяє підказати редактору, що параметр
          з ім'ям name має тип, вказаний в {}. Це може бути number, string,
          boolean, null, undefined для примітивних значень, або number[] для
          масиву чисел, string[] для масиву рядків, тощо.
        </p>
        <p>
          Також в {} можна записати два чи більше типів через |, тоді параметр
          має бути одного з цих типів. Наприклад:
        </p>
        <pre>
          /**
          * @param {number|string} id
          */
          function check(id) {}
        </pre>
        <p>
          Аналогічно, тип, що стоїть після @returns {type}, підказує тип
          значення, яке має повертати функція.
        </p>
        <h3>Умовний (тернарний) оператор</h3>
        <p>
          Іноді необхідно записати різні значення в змінну залежно від умови. Це
          можна зробити за допомогою if та else:
        </p>
        <pre>
          let age = 23;
          let result = '';
          // умова
          if (age >= 18) {
            // значення1
            result = 'Дорослий';
          } else {
            // значення2
            result = 'Не дорослий';
          }
          console.log(result); // 'Дорослий'
        </pre>
        <p>Але це не дуже зручно з двох причин:</p>
        <ol>
          <li>Занадто велика конструкція.</li>
          <li>
            Ми не зможемо використати const для змінної result, тому що нам
            потрібно записати в неї нове значення всередині if else.
          </li>
        </ol>
        <p>
          Є коротший та зручніший варіант запису — умовний (тернарний) оператор.
          Розглянемо приклад:
        </p>
        <pre>
          let age = 23;
          const result = age >= 18 ? 'Дорослий' : 'Не дорослий';
          console.log(result); // 'Дорослий'
        </pre>
        <p>
          Якщо умова age >= 18 виконалася (як у нашому прикладі), то буде обрано
          те, що стоїть після ? ('Дорослий'), інакше — те, що стоїть після :
          ('Не дорослий').
        </p>
        <p>Для наочності, вираз в умові можна взяти в дужки:</p>
        <pre>
          const result = (age >= 18) ? 'Дорослий' : 'Не дорослий';
        </pre>
        <p>Якщо вираз довгий, то можна переносити значення на нові рядки:</p>
        <pre>
          const result = (age >= 18)
          ? 'Дорослий'
          : 'Не дорослий';
        </pre>
        <p>
          Цей оператор часто називають тернарним, оскільки це єдиний оператор, у
          якому використовуються 3 частини.
        </p>
      </section>
      <section class="Useful-links">
        <p>Корисні посилання</p>
        <hr />
        <p>
          <a
            href="https://doc.clickup.com/24383048/p/h/q83j8-478895/5c8e6ac12123a17"
            >Комбінації клавіш VSCode</a
          >
        </p>
        <p>
          <a
            href="https://doc.clickup.com/24383048/p/h/q83j8-478955/72cf30d21cab1bc"
            >Словничок термінів</a
          >
        </p>
        <p>
          <a href="https://javascript.info/coding-style">Coding Style</a>
        </p>
        <p>
          <a href="https://javascript.info/strict-mode"
            >The modern mode, "use strict"</a
          >
        </p>
        <p>
          <a href="https://javascript.info/ninja-code"
            >Ninja code (bad code style examples)</a
          >
        </p>
      </section>
      <section class="Working-With-Numbers">
        <h1 class="main-topic-title">Работа с числами</h1>
        <hr />
        <p>
          Як розробники програмного забезпечення, ми повинні виконувати типові
          операції з числами: округлення їх, перетворення введення користувача в
          числа, генерацію випадкових чисел тощо. У цій темі ми практикуємося у
          виконанні цих рутинних завдань.
        </p>
        <h3>Числові літерали</h3>
        <hr />
        <p>
          У JavaScript числа бувають цілі та з дробовою частиною. Для запису
          чисел використовуються літерали (від англ. «literally» — буквально)
        </p>
        <p>
          Залежно від системи числення, існують різні способи запису числа. Для
          прикладу, візьмемо десяткове число 123 та запишемо його в різних
          системах:
        </p>
        <pre>
          let dec = 123; // 10-кова система
          let hex = 0x7b; // `0x` — префікс 16-кової системи.           Саме число — `7b`
          let bin = 0b1111011; // `0b` — префікс 2-кової системи.           Саме число — `1111011`
          let oct = 0o173; // `0o` — префікс 8-кової системи.           Саме число — `173`
        </pre>
        <p>
          Найчастіше ми будемо працювати з десятковими числами. Їх теж можна
          записати кількома способами:
        </p>
        <pre>
          let x = 15; // ціле десяткове число
          let y = 0.52; // число з дробовою частиною
          let z = 3.14e6; // `e6` означає помножити на `10` в `6`           степені, тобто наше число – `3140000` 
        </pre>
        <h3>Бінарні та шістнадцяткові числа</h3>
        <hr />
        <p>
          Звична нам десяткова система є позиційною, тому кожна цифра множиться
          на 10 у відповідному степені (позиція від правого краю, рахуючи з 0).
          Розглянемо число 345:
        </p>
        <pre>
          345 === 3 * (10 ** 2) + 4 * (10 ** 1) + 5 * (10 ** 0)
          345 === (3 * 100) + (4 * 10) + (5 * 1)
        </pre>
        <p>
          У двійковій системі є лише цифри 0 та 1, які треба множити на 2 у
          відповідному степені:
        </p>
        <pre>
          0b101101 === 1 * (2 ** 5) + 0 * (2 ** 4) + 1 * (2 ** 3) + 1 * (2 ** 2) + 0 * (2 ** 1) + 1 * (2 ** 0)
          0b101101 === (1 * 32) + (0 * 16) + (1 * 8) + (1 * 4) + (0 * 2) + (1 * 1)
          0b101101 === 32 + 8 + 4 + 1 === 45
        </pre>
        <p>
          У шістнадцятковій системі використовуються цифри від 0 до 9 і літери A
          = 10, B = 11, C = 12, D = 13, E = 14 та F = 15:
        </p>
        <pre>
          0x9F2C = 9 * (16 ** 3) + 15 * (16 ** 2) + 2 * (16 ** 1) + 12 * (16 ** 0)
          0x9F2C = (9 * 4096) + (15 * 256) + (2 * 16) + (12 * 1)
          0x9F2C = 36864 + 3840 + 32 + 12 === 40748
        </pre>
        <h3>Округлення значень</h3>
        <hr />
        <p>
          Дуже часто в процесі обчислень у тебе будуть виходити не цілі числа, а
          дробові. Їх можна округлити:
        </p>
        <ul>
          <li>
            <b>Math.round(x)</b> — округляє x до найближчого цілого (вгору або
            вниз):
            <pre>
              console.log(
                Math.round(10.1), // 10
                Math.round(10.5), // 11
                Math.round(10.8), // 11
                Math.round(-10.1), // -10
                Math.round(-10.5), // -10
                Math.round(-10.8), // -11
              );
            </pre>
          </li>
          <li>
            <b>Math.floor(x) </b>— округляє x вниз (до найближчого меншого
            цілого):
            <pre>
              console.log(
                Math.floor(10.1), // 10
                Math.floor(10.5), // 10
                Math.floor(10.8), // 10
                Math.floor(-10.1), // -11
                Math.floor(-10.5), // -11
                Math.floor(-10.8), // -11
              );
            </pre>
          </li>
          <li>
            <b>Math.ceil(x)</b> — округляє x вгору (до найближчого більшого
            цілого):
            <pre>
              console.log(
                Math.ceil(10.1), // 11
                Math.ceil(10.5), // 11
                Math.ceil(10.8), // 11
                Math.ceil(-10.1), // -10
                Math.ceil(-10.5), // -10
                Math.ceil(-10.8), // -10
              );
            </pre>
          </li>
          <li>
            <b>Math.trunc(x)</b> — відкидає дробову частину:
            <pre>
              console.log(
              Math.trunc(10.1), // 10
              Math.trunc(10.5), // 10
              Math.trunc(10.8), // 10
              Math.trunc(-10.1), // -10
              Math.trunc(-10.5), // -10
              Math.trunc(-10.8), // -10
            );
            </pre>
          </li>
          <li>
            x.toFixed(numberOfDigits) перетворює число на рядок із заданою
            кількістю цифр після коми:
            <pre>
              console.log(
              (3.14159).toFixed(0), // '3'
              (3.14159).toFixed(2), // '3.14'
              (3.14159).toFixed(3), // '3.142'
              (3.14159).toFixed(4), // '3.1416'
              (3.14).toFixed(4), // '3.1400'
              (3).toFixed(4), // '3.0000'
              (-3.14159).toFixed(4), // '-3.1416'
            );
            </pre>
          </li>
        </ul>
        <h3>Перетворення рядка на число</h3>
        <hr />
        <p>
          При отриманні даних введених користувачем, числа можуть бути записані
          як рядки що місять цифри. Звісно в програмі нам потрібно перетворити
          такий "числовий" рядок на число. Для цього існує декілька способів.
        </p>
        <p>Для строгого перетворення зазвичай використовують оператор +:</p>
        <pre>
          const text = '3.14159';

          console.log(
            +text, // 3.14159
            +'27.5', // 27.5
            +'2.4e3', // 2400 - експоненційний формат
            +'0xABC', // 2748 - шістнадцяткове число
            +'0b1001', // 9 - бінарне число
          );
        </pre>
        <p>Аналогічним чином працює стандартна функція Number:</p>
        <pre>
          console.log(
            Number(text), // 3.14159
            Number('27.5'), // 27.5
            Number('2.4e3'), // 2400 - експоненційний формат
            Number('0xABC'), // 2748 - шістнадцяткове число
            Number('0b1001'), // 9 - бінарне число
          );
        </pre>
        <p>Також на число можна перетворити значення інших типів:</p>
        <pre>
          console.log(+true); // 1
            console.log(+false); // 0
            console.log(+null); // 0 
            console.log(+undefined); // NaN 
        </pre>
        <p>
          Якщо повне перетворення рядка на число неможливе, то результатом
          перетворення буде значення NaN:
        </p>
        <pre>
          const text = 'Hello';

          console.log(
            +text, // NaN - текст не є числом
            +'35$', // NaN - $ не є валідним символом числа
            +'2.4.3', // NaN - друга десяткова . не допускається
            +'0xABCZ', // NaN - Z не є валідним символом у 16-вій системі
            +'0b10012', // NaN - 2 не є валідним символом у 2-вій системі
          );
        </pre>
        <p>
          Для часткового перетворення числового рядка використовуються
          стандартні функції parseInt та parseFloat.
        </p>
        <p>
          <b>parseInt</b> приймає два параметри: значення для перетворення та
          систему числення (опціонально), і повертає ціле число, або NaN, якщо
          рядок не починається з числа:
        </p>
        <pre>
          parseInt('256$'); // 256 - зупиняємось на першому символі, що не є частиною цілого числа
          parseInt('123.456'); // 123 - дробова частина відкидається
          parseInt('256', 2); // NaN - бо такі цифри не існують в двійковій системі
          parseInt('1A'); // 1 - літера `А` ігнорується
          parseInt('1A', 16); // 26 — шістнадцяткове число
          parseInt('abc'); // NaN - рядок не починається з числа в 10-вій системі
        </pre>
        <p>
          <b>parseFloat</b> приймає значення для перетворення і число або NaN,
          якщо конвертація неможлива, наприклад:
        </p>
        <pre>
          parseFloat('3.14'); // 3.14
          parseFloat('2.718 is the base of natural logarithm'); // 2.718
          parseFloat('abc'); // NaN, бо рядок не починається з числа
        </pre>
        <h3>Infinity та NaN</h3>
        <hr />
        <p>
          В JavaScript існує 2 спеціальних числових значення: Infinity та NaN.
        </p>
        <p>
          <b>Infinity</b> — це математична безкінечність. Вона виникає при
          діленні на 0 і є більшою за будь-яке число. Також є -Infinity — вона
          менша за будь-яке число.
        </p>
        <p>
          <b>Функція isFinite()</b> перетворює аргумент у число та повертає
          true, якщо це звичайне число, а не <b>NaN чи Infinity</b>.
        </p>
        <p>
          <b>NaN</b> — це спеціальне числове значення, яке виникає при помилці
          обчислення. Наприклад, якщо 0 поділити на 0, або число на рядок, який
          не може бути приведений до числа (346 / 'apple'). Значення NaN
          унікальне тим, що воно не дорівнює нічому іншому, навіть самому собі:
        </p>
        <pre>
          console.log(NaN === NaN); // false
        </pre>
        <p>
          Також існує <b>функція isNaN</b>, яка перетворює свій аргумент на
          число і визначає, чи є воно NaN (не числом) чи ні:
        </p>
        <pre>
          isNaN(NaN); // true
          isNaN(45.2); // false
          isNaN(Infinity); // false
          isNaN('123'); // false
          isNaN('0x123'); // false
          isNaN('12 hello'); // true
        </pre>
        <h3>Генерація випадкового числа</h3>
        <hr />
        <p>
          <b>Метод Math.random</b> повертає випадкове число від 0 (включно) до 1
          (не включно):
        </p>
        <pre>
          console.log(
            Math.random(), // 0.6460395007021751
            Math.random(), // 0.511311069945108
            Math.random(), // 0.36258333704200685
          );
        </pre>
        <p>
          Для генерації випадкових цілих чисел від 0 до n треба помножити
          результат на n + 1 та округлити вниз (до меншого цілого):
        </p>
        <pre>
          Math.floor(Math.random() * 11); // випадкове ціле число від 0 до 10 включно
        </pre>
        <p>
          Якщо потрібно випадкове ціле число від min до max включно, то
          генерують число від 0 до max - min і додають min
        </p>
        <pre>
          Math.floor(Math.random() * (max - min + 1)) + min;
          Math.floor(Math.random() * (11 - 7 + 1)) + 7; // випадкове ціле число від 7 до 11 включно
          Math.floor(Math.random() * (20 - 10 + 1)) + 10; // випадкове ціле число від 10 до 20 включно
        </pre>
      </section>
      <section class="Useful-links">
        <p>Корисні посилання</p>
        <hr />
        <p>
          <a
            href="https://developer.mozilla.org/ru/docs/Learn/JavaScript/First_steps/Math"
            >Basic Math in JS</a
          >
        </p>
        <p>
          <a
            href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/parseInt"
            >parseInt()</a
          >
        </p>
        <p>
          <a
            href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/parseFloat"
            >parseFloat()</a
          >
        </p>
      </section>
      <section class="Loops_in_Details">
        <h1 class="main-topic-title"></h1>
        <hr />
        <h3>Цикли в деталях</h3>
        <p>У цьому уроці ми розглянемо цикли більш детально.</p>
        <p class="b">debugger</p>
        <p>
          Доволі часто код може працювати не так, як ми очікуємо. Щоб
          розібратися чому, можна використовувати console.log, друкуючи значення
          змінних чи текстові повідомлення.
        </p>
        <p>
          Але в браузері є можливість зупинити виконання програми і продовжити
          його покроково. Для цього в код можна додати команду debugger. Після
          цього треба відкрити в браузері Developer Tools кнопкою F12 і
          перезавантажити сторінку.
        </p>
        <img
          src="https://media.mate.academy/debugger_b5bf7fc024.png"
          alt="picture"
        />
        <p>
          Програма зупиниться на рядку з командою debugger і буде чекати на
          подальші інструкції. Праворуч в розділі Scope можна побачити значення
          змінних.
        </p>
        <p>
          Для продовження виконання можна використати кнопки зі стрілками вгорі
          або клавіші:
        </p>
        <ul>
          <li>F10 щоб перейти до наступної команди</li>
          <li>F11 щоб зайти в функцію</li>
          <li>Shift+F11 щоб вийти з функції</li>
          <li>
            F8 щоб виконати всі команди до наступного debugger або до кінця
            програми
          </li>
        </ul>
        <p>
          Ми дуже радимо написати простий цикл for (як на скріншоті) та виконати
          його покроково, щоб краще зрозуміти, як він працює.
        </p>
      </section>
      <section class="Infinit_Loop_break_and_continue">
        <h1 class="main-topic-title">Безкінечний цикл</h1>
        <hr />
        <p>
          Безкінечним називається такий цикл, умова якого завжди вірна
          (наприклад, true). Це означає, що тіло циклу буде виконуватись вічно.
          Такий цикл може виконуватись доти, доки працює комп'ютер користувача.
          Більшість браузерів можуть це виявити та запропонують зупинити
          виконання такого скрипту.
        </p>
        <p>Приклад безкінечного циклу:</p>
        <pre>
          for (let i = 2; i > 1; i++) {
            console.log(i);
          }
        </pre>
        <h3>break</h3>
        <hr />
        <p>
          Команда break дозволяє в будь-який момент вийти з циклу, навіть якщо
          умова досі істинна. Після цієї команди виконання циклу повністю
          переривається, і починає виконуватись код, що йде після циклу:
        </p>
        <pre>
          for (let i = 2; i > 1; i++) {
            if (i === 9) {
              break;
            }
          
            console.log(i);
          }
          
        </pre>
        <p>
          Тепер, як тільки i стане рівним 9, цикл закінчиться. Значення 9 навіть
          не надрукується в консолі.
        </p>
        <h3>continue</h3>
        <hr />
        <p>
          Іноді буває необхідно перейти до наступної ітерації циклу, не
          виконуючи команди, що стоять нижче в тілі циклу. Для цього існує
          команда continue:
        </p>
        <pre>
          for (let i = 1; i <= 10; i++) {
            if (i === 5) {
              continue;
            }
          
            console.log(i);
          }
        </pre>
        <p>
          При цьому для i === 5 ми не будемо виконувати команду console.log(i);.
          Звісно того ж самого можна досягти, змінивши умову на протилежну і
          перемістивши команду всередину if:
        </p>
        <pre>
          for (let i = 1; i <= 10; i++) {
            if (i !== 5) {
              console.log(i);
            }
          }
          
        </pre>
        <p>Але, якщо код ускладниться, то можуть з'явитися вкладені умови:</p>
        <pre>
          for (let i = 1; i <= 10; i++) {
            if (i % 2 === 0) {
              console.log('Even number');
          
              if (i === 4) {
                console.log(i);   
              }
            }
          }
          
        </pre>
        <p>І цієї вкладеності можна позбутися з використанням continue;</p>
        <pre>
          for (let i = 1; i <= 10; i++) {
            if (i % 2 !== 0) {
              continue;
            }
          
            console.log('Even number');
          
            if (i === 4) {
              console.log(i);   
            }
          }
        </pre>
        <h3>Цикл while</h3>
        <hr />
        <p>
          Іноді ми не знаємо заздалегідь, скільки разів потрібно виконати ту чи
          іншу команду. Наприклад, при розкладанні числа на дільники, чи пошуку
          остачі.
        </p>
        <p>
          У таких випадках можна скористатися циклом while, який буде
          виконуватися, поки його умова істинна. <br />
          Розглянемо приклад:
        </p>
        <pre>
          let value = 22;

          while (value >= 5) {
            value -= 5; // 17, 12, 7, 2
          }

          console.log(value); // 2
        </pre>
        <p>
          Тут value >= 5 — це умова. Якщо вона істинна, то виконається тіло
          циклу.
        </p>
        <h3>Цикл do while</h3>
        <hr />
        <p>
          Якщо нам потрібно перевіряти умову після першої ітерації (а не до), то
          підійде цикл із постумовою do while.
        </p>
        <p>
          Він подібний до циклу while, але перевіряє умову вже після виконання
          тіла циклу. <br />
          Розглянемо приклад:
        </p>
        <pre>
          let i = 0;

          do {
            console.log(i);
            i++;
          } while (i < 3);
        </pre>
        <p>У консолі ми побачимо:</p>
        <pre>
          0
          1
          2
        </pre>
        <p>Розглянемо ще один приклад:</p>
        <pre>
          let i = 7;

          do {
            console.log(i);
            i++;
          } while (i < 3);
        </pre>
        <p>
          На відміну від циклу while (i < 3), цей код надрукує 7 і лише потім
          завершиться, незважаючи на те, що умова одразу хибна.
        </p>
        <p>На практиці цикл do while використовується вкрай рідко.</p>
        <h3>while(true)</h3>
        <hr />
        <p>
          Іноді одні й ті самі команди треба виконувати перед початком циклу, та
          на кожній ітерації. Наприклад, якщо потрібно друкувати в консоль
          випадкові числа, поки вони < 0.9. Для цього можна написати наступний
          код:
        </p>
        <pre>
          let n = Math.random();

          while (n < 0.9) {
            console.log(n);
            n = Math.random();
          }
        </pre>
        <p>
          Як ти бачиш, нам довелося двічі написати рядок генерації випадкового
          числа. Цикл з постумовою тут не допоможе, бо завжди друкуватиме перше
          число незалежно від умови:
        </p>
        <pre>
          do {
            let n = Math.random();
          
            console.log(n);
          } while (n < 0.9)
          
        </pre>
        <p>Тут нам може допомогти break:</p>
        <pre>
          do {
            let n = Math.random();
          
            if (n < 0.9) {
              break;
            }
          
            console.log(n);
          } while (n < 0.9)
          
        </pre>
        <p>
          Але тепер ми перевіряємо ту саму умову двічі. Хоча насправді тепер
          умова для while нам не потрібна. Її можна замінити на true:
        </p>
        <pre>
          do {
            let n = Math.random();
          
            if (n < 0.9) {
              break;
            }
          
            console.log(n);
          } while (true)
          
        </pre>
        <p>
          І тепер не важливо, де стоїть while, на початку чи в кінці, вихід з
          циклу відбудеться тільки якщо спрацює break:
        </p>
        <pre>
          while (true) {
            let n = Math.random();
          
            if (n < 0.9) {
              break;
            }
          
            console.log(n);
          }
          
        </pre>
      </section>
      <section class="Working_With_Strings">
        <h1 class="main-topic-title">
          Getting Characters in a String / Робота з рядками
        </h1>
        <hr />
        <p>
          Тобі часто доведеться виконувати різні операції з рядками. Наприклад,
          отримувати довжину або знаходити символ на певній позиції. У цьому
          уроці ми розглянемо найтиповіші операції з рядками.
        </p>
        <h3>Символ у рядку</h3>
        <p>
          Отримати окремий символ у рядку можна за його індексом. Індекси в
          рядку починаються з 0 (не з 1). Наприклад:
        </p>
        <pre>
          const fullName = 'Misha Hrynko';

          console.log(
            fullName[0], // 'M'
            fullName[1], // 'i'
            fullName[5], // ' '
            fullName[11], // 'o'
  
            // індекс останнього символа на 1 менше за довжину рядка
            fullName[fullName.length - 1], // 'o'

            // якщо індекс від'ємний або завеликий, отримаємо `undefined`
            fullName[100], // undefined
            fullName[-5] // undefined
          );

        </pre>

        <h3>Special Characters / Спеціальні символи</h3>
        <hr />
        <p>
          Деякі символи неможливо вставити в рядок просто надрукувавши його,
          наприклад, одинарні лапки або перенос рядка. Але такі символи можна
          екранувати за допомогою оберненого слешу — \, наприклад:
        </p>
        <pre>
          const str = 'first \' line\
          second \\ line';

          /*
          first ' line
          second \ line
          */

        </pre>
        <p>
          Якщо ми не поставимо \ перед ' після слова first, JavaScript читатиме
          це як закриваючі лапки. Таким чином, текст після буде аналізуватися як
          команди, але не як рядковий літерал. У комбінації з іншими символами,
          \ має такі значення:
        </p>
        <ul>
          <li>
            \n додає перенесення рядка в одинарних і подвійних лапках:
            <pre>
              const greeting = 'Hello! \n I am Alex.'

              console.log(greeting);

              /*
              Hello!
              I am Alex.
              */

            </pre>
          </li>
          <li>
            \\ додає в рядок обернений слеш — перший із них є символом
            екранування, а другий потрапляє безпосередньо в рядок;
          </li>
          <li>\t додає в рядок табуляцію.</li>
        </ul>

        <h3>String Comparison / Код символу та порівняння рядків</h3>
        <hr />

        <p>
          Рядки складаються із символів. Ми вже знаємо, що в кожного символу є
          індекс — його позиція в рядку. Крім індексу, кожен символ має ще й
          свій код.
        </p>
        <p>
          Символ у рядок можна додати за кодом. Наприклад, символ © можна додати
          такими способами:
        </p>
        <pre>
          console.log('\xA9');
          console.log('\u00A9');
          console.log('\u{A9}');

        </pre>
        <p>
          Щоб отримати код символу, можна використати метод charCodeAt.
          Параметром цей метод приймає індекс символу в рядку:
        </p>
        <pre>
          'Appple'.charCodeAt(0) // `65` — це код `A`

        </pre>
        <p>
          JavaScript дозволяє не тільки із символу отримати його код, але й
          навпаки, з коду отримати символ. Для цього існує метод
          String.fromCharCode():
        </p>
        <pre>
          String.fromCharCode(65); // 'A'
        </pre>
        <p>
          В JavaScript рядки порівнюються посимвольно, а точніше, по кодах
          символів. Порівнюючи рядки, слід враховувати ряд особливостей:
        </p>
        <ul>
          <li>маленькі літери більші, ніж великі;</li>
          <li>
            спецсимволи та літери з діакритичними знаками, наприклад, Ö, йдуть
            після основного алфавіту.
          </li>
        </ul>
        <p>
          Щоб порівняти рядки з врахуванням особливостей алфавіту та регістру,
          існує метод localeCompare. Він має синтаксис str1.localeCompare(str2)
          та повертає число:
        </p>
        <ul>
          <li>від'ємне, якщо рядок str1 менший, ніж str2;</li>
          <li>додатне, якщо рядок str1 більший, ніж str2;</li>
          <li>0, якщо рядки рівні.</li>
        </ul>
        <pre>
          console.log('Ö' < 'Z'); // false
  
          // але
          console.log('Ö'.localeCompare('Z')); // -1
        </pre>
      </section>
      <section class="Converting_to_String">
        <h1 class="main-topic-title">Перетворення в рядок і назад</h1>
        <hr />
        <p>
          Іноді потрібно перетворити число на рядок. Це можна зробити кількома
          способами:
        </p>
        <pre>
          const n = -123;

          console.log(
            String(n), // '-123'
            n.toString(), // '-123'
            `${n}`, // '-123'
            '' + n, // '-123'
          );

        </pre>
        <p>Таким способом можна отримати окрему цифру числа:</p>
        <pre>
          function getFirstDigit(n) {
            return String(n)[0];
          }
          
          console.log(
            getFirstDigit(123), // '1'
            getFirstDigit(76543), // '7'
            getFirstDigit(0), // '0'
          );
          
        </pre>
        <p>
          Але коли ми працюємо із символами, результат завжди є рядком. Якщо
          далі потрібно буде число, то доведеться зробити явне приведення типів:
        </p>
        <pre>
          const digits = '123';

          console.log(
            Number(digits), // 123
            +digits, // 123
          );

        </pre>
        <p>На практиці найчастіше використовують оператор +.</p>
      </section>
      <section class="Text-Case">
        <h3 class="main-topic-title">Text Case / Регістр тексту</h3>
        <hr />
        <p>
          Методи toUpperCase() та toLowerCase() повертають новий рядок, у якому
          всі символи вхідного рядка будуть у верхньому або нижньому регістрі.
          <br />
          Наприклад:
        </p>
        <pre>
          const name = 'Misha';

          console.log(
            name.toLowerCase(), // 'misha'
            name.toUpperCase(), // 'MISHA'

            name[0].toLowerCase(), // 'm'
            name[0].toUpperCase(), // 'M'
          );

        </pre>
        <p>Зверни увагу: змінити регістр можна тільки для літер:</p>
        <pre>
          console.log(
          '1'.toLowerCase(), // '1'
          '1'.toUpperCase(), // '1'
          ','.toUpperCase(), // ','
          ' '.toUpperCase(), // ' '
          ''.toUpperCase(), // ''
        );

        </pre>
        <p>Ця особливість дозволяє перевірити, чи є символ літерою:</p>
        <pre>
          function isLetter(ch) {
            return ch.toLowerCase() !== ch.toUpperCase();
          }
          
          console.log(
            isLetter('a'), // true
            isLetter('B'), // true
            isLetter('1'), // false
            isLetter(','), // false
            isLetter(' '), // false
          );
          
        </pre>
        <p>Код нижче перевіряє, чи є літера великою:</p>
        <pre>
          function isBigLetter(ch) {
            return ch !== ch.toLowerCase();
          }
          
          console.log(
            isBigLetter('A'), // true
            isBigLetter('a'), // false
            isBigLetter('1'), // false
            isBigLetter(','), // false
            isBigLetter(' '), // false
          );
          
        </pre>
      </section>
      <section class="String-Modification-Methods">
        <h3 class="main-topic-title">
          String Modification Methods / Видалення пробілів
        </h3>
        <hr />
        <p>
          За допомогою методу trim() можна видалити всі пробіли на початку та в
          кінці рядку, наприклад:
        </p>
        <pre>
          const name = '       Misha';
          const fullName = 'Misha Hrynko      ';
          const word = '     abrakadabra     ';

          console.log(
            name.trim(), // 'Misha'
            fullName.trim(), // 'Misha Hrynko'
            word.trim(), // 'abrakadabra'
          );
        </pre>
        <h3>padStart та padEnd</h3>
        <hr />
        <p>
          Метод padStart додає новий рядок до початку існуючого рядка. Він має
          синтаксис padStart(targetLength, padString), де targetLength — це
          довжина результуючого рядка, а padString — це рядок, який ми додамо до
          існуючого (значення за замовчуванням — пробіл):
        </p>
        <pre>
          const word = 'fruit';

          console.log(word.padStart(10, '*')); // '*****fruit'
          console.log(word.padStart(10, ' ')); // '     fruit'
          console.log(word.padStart(10)); // '     fruit'
          console.log(word.padStart(19, '0123456789')); // '01234567890123fruit'

        </pre>
        <p>Метод padEnd() додає новий рядок у кінець існуючого рядка:</p>
        <pre>
          const word = 'fruit';

          console.log(word.padEnd(10)); // 'fruit     '
          console.log(word.padEnd(10, '3')); // 'fruit33333'
          console.log(word.padEnd(17, ' yummy')); // 'fruit yummy yummy'

        </pre>
        <h3>repeat</h3>
        <hr />
        <p>Метод repeat повторює рядок у вказане число разів:</p>
        <pre>
          const newString = 'John'.repeat(2);

          console.log(newString); // 'JohnJohn'

        </pre>
      </section>
      <section class="Finding-Substring">
        <h3 class="main-topic-title">Finding a Substring / Пошук підрядка</h3>
        <hr />
        <p>
          За допомогою методу includes() можна перевірити, чи містить рядок
          певний символ або підрядок, наприклад:
        </p>
        <pre>
          const name = 'Misha';

          console.log(
            name.includes('M'), // true
            name.includes('e'), // false
  
            // у рядку є тільки велика літера `M`
            name.includes('m'), // false
  
            // шукаємо підрядок
            name.includes('Mis'), // true
            name.includes('mis'), // false
  
            // підрядок шукається повністю, а не окремі літери
            name.includes('ia'), // false
          );

        </pre>
        <p>
          Пошук можна розпочати не з початку, а із зазначеного індексу. Для
          цього потрібно передати стартовий індекс другим аргументом, наприклад:
        </p>
        <pre>
          const word = 'abrakadabra';

          console.log(
            word.includes('k'), // true
  
            // 'k' стоїть на 4-ому індексі, а ми починаємо перевірку з 5-го 
            word.includes('k', 5), // false
  
            // якщо індекс більше довжини рядка, повертаємо false
            word.includes('b', 15), // false
  
            // якщо індекс від'ємний, шукаємо з кінця рядка
            word.includes('b', -1), // true
            word.includes('b', -100), // true
          );

        </pre>
        <h3>Регістронезалежний пошук</h3>
        <p>
          Якщо ти хочеш перевірити, чи містить рядок певний підрядок без
          урахування регістру, то потрібно привести рядок і підрядок до одного
          регістру (наприклад, до нижнього):
        </p>
        <pre>
          function search(text, part) {
            const normalizedText = text.toLowerCase();
            const normalizedPart = part.toLowerCase();
            
            return normalizedText.includes(normalizedPart);
          }
          
          console.log(
            search('Misha', 'm'), // true
            search('Misha', 'SHA'), // true
          );
          
        </pre>
        <h3>Пошук на початку і в кінці рядка</h3>
        <p>
          За допомогою методу startsWith() можна визначити, чи починається рядок
          із певного підрядка, а endsWith() — чи закінчується рядок певним
          підрядком. <br />Наприклад:
        </p>
        <pre>
          const name = 'Misha';

          console.log(
            name.startsWith('Mis'), // true
            name.startsWith('Misha'), // true
            name.startsWith('M'), // true
  
            name.startsWith('is'), // false
            name.startsWith('a'), // false
          );

          console.log(
            name.endsWith('a'), // true
            name.endsWith('sha'), // true
            name.endsWith('Misha'), // true

            name.endsWith('is'), // false
            name.endsWith('Mi'), // false
          );

        </pre>
        <h3>Пошук індексу</h3>
        <hr />
        <p>
          Щоб дізнатися, де в рядку вперше зустрічається символ чи підрядок,
          можна використати метод indexOf(). Якщо символ або підрядок знайдено,
          то повернеться індекс першого входження. Якщо не знайдені —
          повернеться -1. <br />Наприклад:
        </p>
        <pre>
          const name = 'My name is Misha';

          console.log(
            name.indexOf('y'), // 1
            name.indexOf('n'), // 3
            name.indexOf('My'), // 0

            // символ не знайдений
            name.indexOf('x'), // -1

            // регістр має значення
            name.indexOf('my'), // -1
  
            // індекс першого входження
            name.indexOf('M'), // 0
            name.indexOf('a'), // 4
            name.indexOf(' '), // 2
  
            // маленька літера 'm' стоїть шостою
            name.indexOf('m'), // 5
          );

        </pre>
        <p>
          Якщо пошук позиції потрібно почати з певного індексу, передай його
          другим аргументом:
        </p>
        <pre>
          const name = 'My name is Misha';

          console.log(
            name.indexOf('M'), // 0
            name.indexOf('M', 1), // 11
  
            // 'M' не трапляється, починаючи з 12 індекса
            name.indexOf('M', 12), // -1
          );

        </pre>
        <p>
          Існує метод для пошуку індексу у зворотному напрямку — lastIndexOf().
          Він повертає індекс останнього входження символу або підрядка:
        </p>
        <pre>
          const name = 'My name is Misha';

          console.log(
            name.lastIndexOf('y'), // 1
            name.lastIndexOf('M'), // 11
  
            // можна вказати індекс, з якого починається пошук у зворотній бік
            name.lastIndexOf('M', 10), // 0
          );

        </pre>
      </section>
      <section class="Extracting-Substring">
        <h3 class="main-topic-title">
          Extracting a Substring / Отримання підрядка
        </h3>
        <hr />
        <p>
          Досить часто тобі потрібно буде отримувати частину рядка (підрядок). І
          тут зручно скористатися методом slice(). Він приймає 2 аргументи:
        </p>
        <ul>
          <li>індекс, з якого починається копіювання символів;</li>
          <li>
            індекс, на якому закінчується копіювання символів. Символ за цим
            індексом не буде включений.
          </li>
        </ul>
        <p>Наприклад:</p>
        <pre>
          const text = '0123456789';

          console.log(
            // символ з індексом 5 не буде включений
            text.slice(1, 5), // '1234'
  
            // беремо перші 8 символів
            text.slice(0, 8), // '01234567'

            // якщо початок більший за кінець, отримуємо пустий рядок
            text.slice(5, 1), // ''

            //  без аргументів отримуємо весь рядок
            text.slice(), // '0123456789'

            // якщо другий аргумент не переданий, беремо все до кінця
            text.slice(2), // '23456789'

            // якщо індекс початку занадто великий, отримаємо пустий рядок
            text.slice(15), // ''

            // від'ємні індекси рахуються з кінця
            text.slice(-5, -2), // '567'

            // беремо останні 3 символа
            text.slice(-3), // '789'

            // усі символи окрім 0-го та останнього
            text.slice(1, -1), // '12345678'
          );          

        </pre>
        <p>Цей метод можна використати, щоб зібрати новий рядок із частин:</p>
        <pre>
          const text = 'I have 4 dogs';

          // 'I have five dogs'
          const text2 = text.slice(0, 7) + 'five' + text.slice(-5);
          
          // 'We don't have dogs'
          const text3 = `We don't ${text.slice(2, 6)} ${text.slice(-4)}`;

        </pre>
      </section>
      <section class="Useful-links">
        <h3>Корисні посилання</h3>
        <hr />
        <p>
          <a
            href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/at"
            >at()</a
          >
        </p>
        <p>
          <a
            href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/trimStart"
            >trimStart()</a
          >
        </p>
        <p>
          <a
            href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/trimEnd"
            >trimEnd()</a
          >
        </p>
        <p>
          <a
            href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/replace"
            >replace()</a
          >
        </p>
        <p>
          <a
            href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/replaceAll"
            >replaceAll()</a
          >
        </p>
        <p><a href="https://javascript.info/string">Strings</a></p>
      </section>
      <section class="Functions-Revisited">
        <h1 class="main-topic-title">Functions Revisited</h1>
        <hr />
        <p>
          У цьому уроці ви дізнаєтеся, як обробляти пропущені аргументи функцій
          та що таке стрілкові функції.
        </p>
        <h3>Пропущені аргументи та значення за замовчуванням</h3>
        <hr />
        <p>
          Ми вже знаємо, що параметр — це змінна, записана між круглими дужками
          функції під час оголошення. Аргумент — це значення, передане у функцію
          під час її виклику. Аргументи стають значеннями відповідних параметрів
          по порядку: перший аргумент стає значенням першого параметру, другий
          другого, і т.д. <br />
          Наприклад:
        </p>
        <pre>
          function message(text, name) { // `text` та `name` — це параметри
            return `${text}, ${name}!`;
          }
          
          const greeting = message('Hi', 'Alex'); // 'Hi' та 'Alex' — це аргументи
          
          console.log(greeting); // 'Hi, Alex!'
          
        </pre>
        <p>
          Але можна встановити значення за замовчуванням для параметра, тоді
          воно буде використано замість undefined:
        </p>
        <pre>
          function multiply(a, b = 3) { // якщо значення для `b` не буде передано, воно дорівнюватиме `3`
            return a * b;
          }
          
          console.log(multiply(5, 2)); // 10
          console.log(multiply(5)); // 5 * 3 = 15
          
        </pre>
        <p>Параметром за замовчуванням можна задати й вираз:</p>
        <pre>
          function multiply(a, b = a + 10) { // якщо `b` не передано, то його значенням буде `a + 10`
            return a * b;
          }
          
          console.log(multiply(3)); // 3 * 13 = 39
          console.log(multiply(7)); // 7 * 17 = 119
          
        </pre>
      </section>
      <section class="Extra-Arguments">
        <h3 class="main-topic-title">Додаткові аргументи</h3>
        <hr />
        <p>
          Якщо у функцію передано більше аргументів, ніж вона очікує, то «зайві»
          аргументи просто ігноруються:
        </p>
        <pre>
          function multiply(a, b) {
            return a * b;
          }
          
          multiply(3, 4, 5, 6); // поверне `12`, аргументи `5` і `6` ігноруються
          
        </pre>
        <p>
          Якщо потрібно отримати всі передані аргументи, можна використати
          оператор rest, наприклад ...args. У цьому випадку args буде масивом,
          який містить усі аргументи, передані у функцію:
        </p>
        <pre>
          function sum(...args) {
            console.log(args);
          }
          
          sum(3, 4); // args = [3, 4]
          sum(3, 4, 5, 6); // args = [3, 4, 5, 6]
          
        </pre>
        <p>
          Також за потреби можна отримати частину аргументів до окремих
          параметрів, а решту зібрати в масив:
        </p>
        <pre>
          function sum(x, ...args) {
            console.log(x, args);
          }
          
          sum(); // x = undefined, args = []
          sum(1, 2); // x = 1, args = [2]
          sum(3, 4, 5, 6); // x = 3, args = [4, 5, 6]
          
        </pre>
      </section>
      <section class="Function-Declaration-Expression">
        <h3 class="main-topic-title">
          Оголошення Функції (Function Declaration) та Функціональний Вираз
          (Function Expression)
        </h3>
        <hr />
        <p>
          Раніше ми завжди оголошували функції окремо від іншого коду. Їх можна
          викликати як до, так і після оголошення:
        </p>
        <pre>
          const result1 = sum(1, 2);

          function sum(a, b) {
            return a + b;
          }
          
          const result2 = sum(3, 4);

        </pre>
        <p>
          Але іноді буває зручно присвоїти функцію змінній (наприклад, в
          залежності від умов):
        </p>
        <pre>
          const operation = function sum(a, b) {
            return a + b;
          };
          
          const result = operation(1, 2); // result = 3
          
        </pre>
        <p>
          Таке створення функції називається функціональним виразом (Function
          Expression). Її можна викликати тільки після присвоєння, і тільки за
          іменем змінної, куди вона присвоєна:
        </p>
        <pre>
          operation(1, 2); // Uncaught ReferenceError: Cannot access 'operation' before initialization

          const operation = function sum(a, b) {
            return a + b;
          };

          sum(1, 2); // Uncaught ReferenceError: sum is not defined

        </pre>
      </section>
      <section class="Arrow-Function">
        <h3 class="main-topic-title">Функція-стрілка</h3>
        <hr />
        <p>
          Функції у програмах використовують дуже часто, тому для максимального
          скорочення часто використовують => (стрілку) після круглих дужок
          замість слова function перед ними. Наступні дві функції працюватимуть
          однаково:
        </p>
        <pre>
          const sum1 = function(a, b) {
            return a + b;
          };
          
          const sum2 = (a, b) => {
            return a + b;
          };
          
        </pre>
        <p>
          Якщо функція одразу повертає результат, то {} та return можна прибрати
          і записати результат після стрілки:
        </p>
        <pre>
          let sum = (a, b) => a + b;

        </pre>
        <p>Якщо аргумент лише один, його можна написати без дужок:</p>
        <pre>
          let sum = () => 3 + 5;

        </pre>
        <p>Якщо аргументів немає, круглі дужки все одно повинні бути:</p>
        <pre>
          let sum = () => 3 + 5;

        </pre>
        <p>
          Так само, як і у звичайній функції, параметрам можна встановлювати
          значення за замовчуванням та використовувати rest-оператор:
        </p>
        <pre>
          let f = (a, b = 10, ...args) => {
            console.log(a, b, args);
          };
          
        </pre>
      </section>
      <section class="Useful-links">
        <h3>Корисні посилання</h3>
        <hr />
        <p>
          <a href="https://javascript.info/function-basics">Functions</a>
        </p>
        <p>
          <a href="https://javascript.info/function-expressions"
            >Function expressions</a
          >
        </p>
        <p>
          <a href="https://javascript.info/arrow-functions-basics"
            >Arrow functions, the basics</a
          >
        </p>
        <p>
          <a
            href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Functions/rest_parameters"
            >Rest parameters</a
          >
        </p>
      </section>
    </div>

    <script src="main.js"></script>
  </body>
</html>
