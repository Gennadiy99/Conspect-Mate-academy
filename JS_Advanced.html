<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>JS Advanced</title>

    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap"
      rel="stylesheet"
    />
    <link rel="icon" href="./images/Logo MateAcademy.png" />
    <link rel="stylesheet" href="style/fontello.css" />
    <link rel="stylesheet" href="style/main.css" />
  </head>

  <body>
    <section class="nav-bar">
      <div class="nav">
        <a href="index.html">Index</a>
        <a href="Git_and_Terminal.html">Git and Terminal</a>
        <a href="JS_Basics _Extended.html">JS Basics Extended</a>
        <a href="HTML_CSS_Advanced.html">HTML + CSS Advanced</a>
        <a href="BEM.html">BEM</a>
        <a href="SASS.html">SASS</a>
        <a href="Transf and Animations.html">Transf Animat</a>
        <a href="JS_Advanced.html">JS Advanced</a>
      </div>
    </section>
    <div class="container">
      <h1>JS Advanced</h1>

      <div class="select-Section-JS">
        <select class="Select-section" name="selectSection">
          <option value="">-- Select section --</option>
          <option value="#">1</option>
          <option value="#Useful-JS-Advanced">Useful links JS-Advanced</option>
          <option value="#Destruct">Object_Destructuring</option>
          <option value="#Useful-Desrt-Copy">Useful links Desrt-Copy</option>
          <option value="#methods-OBJ">methods</option>
          <option value="#Getters">Getters</option>
          <option value="#Setters">Setters</option>
          <option value="#Useful-methods">Useful links methods</option>
          <option value="#Array-Methods">Array Methods</option>
          <option value="#Adding-and-Removing">Adding-and-Removing</option>
          <option value="#Mutating">Mutating</option>
          <option value="#destructuringArray">Destructuring-Array</option>
        </select>
      </div>
      <section class="class=Useful-links" id=" Useful-JS-Advanced">
        <h1>How to Solve Tasks on Github</h1>
        <h2 class="main-topic-title">Корисні посилання</h2>

        <p>
          <a
            href="https://doc.clickup.com/24383048/p/h/q83j8-478895/5c8e6ac12123a17"
          >
            Комбінації клавіш VSCode
          </a>
        </p>

        <p>
          <a
            href="https://doc.clickup.com/24383048/p/h/q83j8-478955/72cf30d21cab1bc"
          >
            Словничок термінів
          </a>
        </p>

        <p>
          <a href="https://code.visualstudio.com/docs/terminal/basics">
            VS Code Terminal Basics
          </a>
        </p>

        <p>
          <a href="https://code.visualstudio.com/docs/editor/debugging">
            VS Code Debugging
          </a>
        </p>

        <p>
          <a href="https://jestjs.io/docs/troubleshooting">
            Tests Troubleshooting
          </a>
        </p>

        <p>
          <a href="https://mate-academy.github.io/fe-program/js/extra/string">
            String Methods Cheatsheet
          </a>
        </p>
      </section>
      <section class="Object_Destructuring" id="Destruct">
        <h2 class="main-topic-title">
          Object Destructuring Диструктуризация обьекта
        </h2>
        <p>
          Очень интересный способ передачи данных из массива или обьекта:
          (Получаем значения из массива и помещаем их в переменные)
        </p>
        <pre>
          const numbers = [1, 2, 3];
          const [a, b, c] = numbers;

          console.log(a); // 1
          console.log(b); // 2
          console.log(c); // 3
        </pre>
        <p>Деструктуризация объекта:</p>
        <pre>
          const user = { name: "Alice", age: 25 };
          const { name, age } = user;

          console.log(name); // "Alice"
          console.log(age);  // 25
        </pre>
        <p>
          Что произошло?<br />
          Переменные name и age получили значения из объекта по ключам
        </p>
        <p>
          Спред-оператор (...) раскрывает элементы массива или свойства
          объекта.<br />
          Спред в массивах:
        </p>
        <pre>
          const arr1 = [1, 2, 3];
          const arr2 = [...arr1, 4, 5];

          console.log(arr2); // [1, 2, 3, 4, 5]
        </pre>
        <p>
          Что произошло?<br />

          ...arr1 развернул элементы [1, 2, 3], добавив [4, 5].
        </p>
        <p>Спред в объектах:</p>
        <pre>
          const user = { name: "Alice", age: 25 };
          const newUser = { ...user, city: "New York" };

          console.log(newUser);
          // { name: "Alice", age: 25, city: "New York" }
        </pre>
        <p>
          Что произошло? <br />
          ...user развернул свойства { name: "Alice", age: 25 }, добавив city.
        </p>
        <p>
          Рест + Деструктуризация Можно использовать "рест" в деструктуризации:
          <b>Оставшиеся элементы в массиве (rest оператор)</b>
        </p>
        <pre>
          const numbers = [1, 2, 3, 4, 5];
          const [first, second, ...rest] = numbers;

          console.log(first); // 1
          console.log(second); // 2
          console.log(rest); // [3, 4, 5]
        </pre>
        <p>
          Что произошло? <br />
          first = 1, second = 2.<br />
          ...rest собирает оставшиеся элементы в массив [3, 4, 5]
        </p>
        <p><b>Оставшиеся свойства в объекте (rest оператор)</b></p>
        <pre>
          const user = { name: "Alice", age: 25, city: "New York" };
          const { name, ...rest } = user;

          console.log(name); // "Alice"
          console.log(rest); // { age: 25, city: "New York" }
        </pre>
        <p>
          Что произошло? <br />
          name извлекается отдельно. <br />
          ...rest собирает оставшиеся свойства { age: 25, city: "New York" }.
        </p>
        <p>
          <b
            >Так же при получении значений в переменную из обьекта, можно
            переименовывать Ключь</b
          ><br />
          При деструктуризации объекта можно переименовывать ключи с помощью
          оператора две точки, - ":"
        </p>
        <pre>
          const user = { 
            name: "Alice", 
            age: 25, 
            city: "New York" 
          };
          
          // Переименовываем ключи при деструктуризации
          const { name: userName, age: userAge, city: userCity } = user;
          
          console.log(userName); // "Alice"
          console.log(userAge);  // 25
          console.log(userCity); // "New York"
        </pre>
        <p>Что произошло?</p>
        <ul>
          <li>name → userName</li>
          <li>age → userAge</li>
          <li>city → userCity</li>
        </ul>
        <p>
          <b>Можно использовать переименование ключей в аргументах функции:</b>
        </p>
        <pre>
          function printUser({ name: userName, age: userAge }) {
            console.log(`Имя: ${userName}, Возраст: ${userAge}`);
          }
          
          const person = { name: "Bob", age: 30 };
          printUser(person); // "Имя: Bob, Возраст: 30"
        </pre>
        <p>
          Что произошло?<br />

          Функция принимает объект, сразу деструктуризируя его и переименовывая
          name → userName, age → userAge.
        </p>
        <p>
          <b
            >Можно переименовывать ключи при деструктуризации:<br />
            const { ключ: новоеИмя } = объект; <br />
            Работает как в обычных переменных, так и в функциях.</b
          >
        </p>
      </section>
      <section class="Useful-links" id="Useful-Desrt-Copy">
        <p>
          <a href="https://javascript.info/object">Objects</a>
        </p>
        <p>
          <a href="https://javascript.info/object-copy"
            >Object references and copying</a
          >
        </p>
      </section>
      <section class="methods OBJ" id="methods-OBJ">
        <h2 class="main-topic-title">Методи об'єкта</h2>
        <hr />
        <h4>
          Метод об'єкта — це властивість, яка містить функцію. Для початку
          розглянемо функцію, яка друкує інформацію про користувача:
        </h4>
        <p>
          Методод это Функция которая хранится в Свойствах обьекта <br />
          <b>this</b> - это То что стоит перед Точкой при вызове.
        </p>
        <pre>
          function printFullName(user) {
            console.log(`${user.firstName} ${user.lastName}`);
          }
          
          const firstUser = {
            firstName: 'John',
            lastName: 'Smith',
            age: 25,
            printInfo: printFullName,
          };
          
          printFullName(firstUser); // John Smith
          
        </pre>
        <p>
          Зараз ми отримуємо об'єкт, як параметр, і виконуємо з ним необхідні
          дії. Проблема такого підходу в тому, що теоретично можна передати не
          об'єкт, а значення іншого типу, або об'єкт, що не містить необхідних
          властивостей. Наприклад:
        </p>
        <pre>
          printFullName({}); // undefined undefined

        </pre>
        <p>
          Звісно, можна додати перевірку типів відповідних властивостей за
          допомогою оператора typeof:
        </p>
        <pre>
            function printFullName(user) {
              if (typeof user.firstName !== 'string'
                || typeof user.lastName !== 'string'
              ) {
                return; // просто завершуємо функцію
              }
            
              console.log(`${user.firstName} ${user.lastName}`);
            }
            
          </pre
        >
        <p>
          Або можна використати TypeScript для перевірки типів (розглянемо його
          пізніше).<br />
          Альтернативою може бути додавання метода до об'єкта:
        </p>
        <pre>
            function printFullName(user) {
              console.log(`${user.firstName} ${user.lastName}`);
            }
            
            const user = {
              firstName: 'John',
              lastName: 'Smith',
              age: 25,
            
              printInfo: printFullName,
            };
            
          </pre
        >
        <p>
          При виклику такого метода замість передачі об'єкта через аргумент,
          можна використати ключове слово <b>this.</b> Воно містить посилання на
          об'єкт, що стоїть перед крапкою при виклику метода:
        </p>
        <pre>
            function printFullName() {
              // Використовуємо `this` замість `user`
              console.log(`${this.firstName} ${this.lastName}`);
            }
            
            const user = {
              firstName: 'John',
              lastName: 'Smith',
              age: 25,
            
              printInfo: printFullName,
            };
            
            user.printInfo(); // John Smith
            
          </pre
        >
        <p>
          Якщо ж таку функцію викликати не як метод об'єкта, то this буде
          невизначений (undefined), і станеться помилка:
        </p>
        <pre>
            printFullName(); // Uncaught TypeError: Cannot read properties of undefined (reading 'firstName')

          </pre
        >
        <p>
          Тому замість створення окремої функції, її можна додати прямо в
          об'єкт:
        </p>
        <pre>
            const user = {
              firstName: 'John',
              lastName: 'Smith',
              age: 25,
            
              printInfo: function() {
                console.log(`${this.firstName} ${this.lastName}`);
              },
            };
            
          </pre
        >
        <p>Або навіть скоротити з використанням синтаксису методів об'єкта:</p>
        <pre>
            const user = {
              firstName: 'John',
              lastName: 'Smith',
              age: 25,
            
              printInfo() {
                console.log(`${this.firstName} ${this.lastName}`);
              },
            };
            
          </pre
        >
        <p>
          Таке поєднання даних з "поведінкою" дозволяє обмежити використання
          метода тільки для "правильних" об'єктів. На такому поєднанні будується
          Об'єктно Орієнтоване Програмування (ООП), яке зараз є доволі
          розповсюдженим при написанні серверних застосунків. Основи ООП ми
          розглянемо пізніше в окремому модулі. Невеликим недоліком є те, що ми
          маємо додавати всі необхідні методи в кожен об'єкт. Пізніше ми
          вирішимо це за допомогою наслідування (в темах Prototype, Constructors
          та Classes).
        </p>
      </section>
      <section class="Getters" id="Getters">
        <h2 class="main-topic-title">
          Обчислювані властивості (Гетери) Getters
        </h2>
        <hr />
        <p>
          Іноді при роботі з об'єктами може виникнути необхідність обчислювати
          якусь інформацію на основі властивостей об'єкта. Наприклад, повне ім'я
          користувача:
        </p>
        <pre>
          const user = {
            firstName: 'John',
            lastName: 'Smith',
          };
          
          user.fullName = `${user.firstName} ${user.lastName}`;
          
          console.log(user.fullName); // 'John Smith'
          
        </pre>
        <p>
          Звісно, якщо змінити ім'я користувача, то fullName не зміниться,
          оскільки ми не присвоюємо нове значення до fullName:
        </p>
        <pre>
          user.firstName = 'Bob';

          console.log(user.fullName); // 'John Smith'

        </pre>
        <p>За допомогою метода цю проблему можна вирішити:</p>
        <pre>
          const user = {
            firstName: 'John',
            lastName: 'Smith',
            
            getFullName() {
              return `${this.firstName} ${this.lastName}`
            }
          };
          
          console.log(user.getFullName()); // 'John Smith'
          
          user.firstName = 'Bob';
          
          console.log(user.getFullName()); // 'Bob Smith'
          
        </pre>
        <p>
          Але це змушує нас переписати весь код, що використовує наш об'єкт, що
          може бути проблематично, особливо, якщо ми написали функцію, яку
          використовують інші розробники. Щоб залишити синтаксис використання
          незмінним, можна застосувати обчислювану властивість (гетер). Її можна
          створити за допомогою ключового слова get і перед назвою метода
          об'єкта:
        </p>
        <pre>
          const user = {
            firstName: 'John',
            lastName: 'Smith',
            
            get fullName() {
              return `${this.firstName} ${this.lastName}`;
            },
          };
          
          console.log(user.fullName); // John Smith
          
          user.firstName = 'Bob';
          
          console.log(user.fullName); // Bob Smith
          
        </pre>
        <p>
          При читанні властивості user.fullName викликається гетер fullName і
          повертає обчислене значення.
        </p>
        <p>
          Зверни увагу, що ми не ставимо круглі дужки після назви, тому гетер не
          може мати жодних параметрів.
        </p>
      </section>
      <section class="Setters" id="Setters">
        <h2 class="main-topic-title">Setters (Сетери)</h2>
        <hr />
        <p>
          <u>Аналогічно до <b>гетерів</b></u
          >, можна додати логіку, яка буде виконуватися, коли ми присвоюємо нове
          значення до властивості об'єкта. Це робиться за допомогою ключового
          слова <b>set</b> перед назвою методу.
        </p>
        <pre>
          const user = {
            firstName: 'John',
            lastName: 'Smith',
            
            set fullName(value) {
              const spacePosition = value.indexOf(' '); // знаходимо перший пробіл
          
              this.firstName = value.slice(0, spacePosition); // Ім'я має бути першим
              this.lastName = value.slice(spacePosition); // Прізвище - другим
            },
          };
          
          user.fullName = 'Mike Brown';
          
          console.log(user.firstName); // 'Mike'
          console.log(user.lastName); // 'Brown'
        </pre>
        <p>Зверни увагу: сетер повинен приймати рівно 1 параметр.</p>
        <p>
          За допомогою сетера можна валідувати нове значення. І звісно, сетер і
          гетер можна використовувати одночасно:
        </p>
        <pre>
          const user = {
            firstName: 'John',
            lastName: 'Smith',
            
            get fullName() {
              return `${this.firstName} ${this.lastName}`;
            },
          
            set fullName(value) {
              if (typeof value !== 'string') {
                return; // невалідний тип даних
              }  
                
              if (!value.includes(' ')) {
                return; // невалідний формат
              }
              
              const spacePosition = value.indexOf(' ');
          
              this.firstName = value.slice(0, spacePosition);
              this.lastName = value.slice(spacePosition);
            },
          };
        </pre>
        <p>
          Якщо додати сетер без <b>гетера</b>, то при читанні отримаємо
          <u>undefined.</u>
        </p>
        <p>
          Якщо ж додати <b>гетер</b> без <b>сетера</b>, то при спробі присвоїти
          отримаємо помилку:
        </p>

        <pre>
          const user = {
            firstName: 'John',
            lastName: 'Smith',
            
            get fullName() {
              return `${this.firstName} ${this.lastName}`;
            },
          };
          
          user.fullName = 'Bob Black'; // Uncaught TypeError: Cannot set property fullName of # &ltObject> which has only a getter 
        </pre>
      </section>
      <section class="Useful-links" id="Useful-methods">
        <p>
          <a href="https://javascript.info/object-methods"
            >Object methods, "this"</a
          >
          <a
            href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get"
            >getter</a
          >
          <a
            href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/set"
            >setter</a
          >
        </p>
      </section>
      <section class="Array Methods" id="Array-Methods">
        <h2 class="main-topic-title">Методи Роботи з Масивами</h2>
        <hr />
        <p>
          У реальному житті ми дуже часто стикаємося з великою кількістю
          однотипних даних: слова в словнику, оцінки в журналі, товари в
          магазині, книги на полиці тощо. В Javascript для роботи з такими
          даними використовуються масиви.
        </p>
        <h2 class="main-topic-title">Створення масивів</h2>
        <hr />
        <p>Пригадаємо декілька способів свтворення нового масиву:</p>
        <pre>
          const daysOfWeek = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];
          const numbers = [2, 5, 3, 4, 5, 1, 3];
          const words = ['John', 25, true]; // кортеж

          // це пустий масив, в ньому поки що немає елементів
          const friends = []; 

          // так теж можна створити масив, але на практиці використовують []
          const marks = new Array(2, 5, 3, 4, 5, 1, 3);
          const marks2 = Array(2, 5, 3, 4, 5, 1, 3);

        </pre>
        <p>
          За допомогою метода <b>split</b> ти можеш створити масив із рядка. Він
          використовується для "розрізання" рядка на підрядки за заданим
          роздільником, наприклад:
        </p>
        <pre>
          const str = 'one; two; three; four; five';

          console.log(
            str.split(' '),  // ['one;', 'two;', 'three;', 'four;', 'five']
            str.split('; '),  // ['one', 'two', 'three', 'four', 'five']
            str.split('; ', 3),  // ['one', 'two', 'three']
            str.split('three'), // ['one; two; ', '; four; five']
          );

        </pre>
        <p>Також можна отримати масив окремих символів рядка:</p>
        <pre>
          const str = 'abc def';

          console.log(
            str.split(''), // ['a', 'b', 'c', ' ', 'd', 'e', 'f']
            Array.from(str), // створюємо масив з символів рядка
            [...str], // спред оператор копіює до нового масиву символи з рядка
          );

        </pre>
        <h2 class="main-topic-title">Об'єднання елементів масиву в рядок</h2>
        <p>
          Метод <b>join</b> використовується для об'єднання елементів масиву в
          рядок. Він приймає роздільник як аргумент і повертає рядок, утворений
          з об'єднаних елементів масиву:
        </p>
        <pre>
          const words = ['Javascript', 'is', 'awesome'];

          console.log(
            words.join(' '), // 'Javascript is awesome'
            words.join(', '), // 'Javascript, is, awesome'
            words.join('---'), // 'Javascript---is---awesome'
          );

        </pre>
        <h3 class="main-topic-title">Отримання елементів масиву</h3>
        <p>Елемент масиву можна отримати за його індексом:</p>
        <pre>
          const daysOfWeek = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];

          console.log(
            daysOfWeek[0], // 'Mon'
            daysOfWeek[1], // 'Tue'
            daysOfWeek[6], // 'Sun'

            // якщо індекс занадто великий, отримуємо undefined
            daysOfWeek[10], // undefined

            // чи від'ємний
            daysOfWeek[-2], // undefined
          );

        </pre>
        <p>
          Також можна скористатися методом at. Він працює так само, як
          arr[index] для додатніх індексів, але обробляє від'ємні, як позиціє з
          кінця масиву. Наприклад:
        </p>
        <pre>
          console.log(
            daysOfWeek.at(-1), // 'Sun'
            daysOfWeek.at(-2), // 'Sat'
            daysOfWeek.at(1), // 'Tue'
          );

        </pre>
        <h3 class="main-topic-title">Перебір елементів масиву</h3>
        <p>
          Для перебору елементів масиву можна скористатися одним з двох циклів:
        </p>
        <pre>
          const daysOfWeek = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];

          for (let i = 0; i < daysOfWeek.length; i++) {
            console.log(daysOfWeek[i]);
          }

          for (const day of daysOfWeek) {
            console.log(day);
          }

        </pre>
        <p>Методи, які дозволяють перебрати масив ми розглянемо пізніше.</p>
      </section>
      <section
        class="Adding and Removing Array Elements"
        id="Adding-and-Removing"
      >
        <h2 class="main-topic-title">Додавання елементів в масив</h2>
        <hr />
        <p>Також можна додати новий елемент до масиву:</p>
        <pre>
          const numbers = [1, 2, 3, 4, 5];

          numbers[5] = 100;
          console.log(numbers); // [1, 2, 3, 4, 5, 100]

        </pre>
        <p>
          Зверни увагу: якщо ми вкажемо неправильний індекс, то масив
          працюватиме некоректно:
        </p>
        <pre>
          const numbers = [1, 2, 3];

          numbers[5] = 100;
          console.log(numbers); // [1, 2, 3, empty, empty, 100]

        </pre>
        <p>
          Щоб уникнути помилки з попереднього прикладу, для додавання елементів
          до масиву використовуй метод push:
        </p>
        <pre>
          const numbers = [1, 2, 3];

          numbers.push(100);
          console.log(numbers); // [1, 2, 3, 100]

          // можна додати одразу декілька елементів
          numbers.push(4, 5, 6);
          console.log(numbers); // [1, 2, 3, 100, 4, 5, 6]

        </pre>
        <p>
          Для додавання елементу на початок масиву існує метод <b>unshift:</b>
        </p>
        <pre>
          const numbers = [1, 2, 3];

          numbers.unshift(100);
          console.log(numbers); // [100, 1, 2, 3]

          // можна додати одразу декілька елементів
          numbers.unshift(4, 5, 6);
          console.log(numbers); // [4, 5, 6, 100, 1, 2, 3]

        </pre>
        <p>
          Методи <b>push та unshift</b> повертають нову довжину масиву (після
          додавання нових елементів):
        </p>
        <pre>
          const numbers = [1, 2, 3];
          const newLength = numbers.push(10, 20);

          console.log(newLength); // 5

        </pre>
        <h3 class="main-topic-title">Видалення елементу з масиву</h3>
        <p>
          Метод <b>pop</b> видаляє останній елемент із масиву, а <b>shift</b> —
          перший. Наприклад:
        </p>
        <pre>
          const numbers = [1, 2, 3, 4, 5];

          numbers.pop();
          console.log(numbers); // [1, 2, 3, 4]

          numbers.shift();
          console.log(numbers); // [2, 3, 4]

        </pre>
        <p>Методи pop та shift повертають видалений елемент:</p>
        <pre>
          const numbers = [1, 2, 3, 4, 5];
          const removedElement = numbers.shift();

          console.log(removedElement); // 1

        </pre>
        <h3 class="main-topic-title">Частина вхідного масиву</h3>
        <hr />
        <p>
          Так саме, як і для рядка, метод slice() дозволяє створити новий масив
          з частиною елементів існуючого:
        </p>
        <pre>
          const numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];

          console.log(
            numbers.slice(3, 8), // [3, 4, 5, 6, 7]
  
            // перші 5 елементів
            numbers.slice(0, 5), // [0, 1, 2, 3, 4]
  
            // елементи від індексу 4 до кінця 
            numbers.slice(4), // [4, 5, 6, 7, 8, 9]
  
            // усі елементи масиву
            numbers.slice(), // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

            // від'ємні індекси рахуються з кінця
            numbers.slice(-6, -2), // [4, 5, 6, 7]

            // усі елементи, крім першого та останнього 
            numbers.slice(1, -1), // [1, 2, 3, 4, 5, 6, 7, 8]

            // останні 3 елементи
            numbers.slice(-3), // [7, 8, 9]
          );

        </pre>
      </section>
      <section class="Mutating" id="Mutating">
        <h2 class="main-topic-title">
          Mutating and No-Mutating Methods / Мутирующие и Не мутирующие Методы
          массивов
        </h2>
        <hr />
        <h3>Редагування масиву</h3>
        <p>
          На відміну від символу в рядку, елемент у масиві можна замінити за
          його індексом:
        </p>
        <pre>
          const numbers = [1, 2, 3, 4, 5];

          numbers[1] = 100;

          console.log(numbers); // [1, 100, 3, 4, 5]

        </pre>
        <p>
          Замінити елементи масиву можна методом
          <b>.fill(value, start, end)</b>:
        </p>
        <pre>
          const numbers1 = [0, 1, 2, 3, 4, 5, 6, 7];

          numbers1.fill(99);
          console.log(numbers1); // [99, 99, 99, 99, 99, 99, 99, 99]

          const numbers2 = [0, 1, 2, 3, 4, 5, 6, 7];

          numbers2.fill(99, 2, -2);
          console.log(numbers2); // [0, 1, 99, 99, 99, 99, 6, 7]

        </pre>
        <p>
          Також для модифікації масиву існує дуже зручний метод
          <b>.splice(startIndex, deleteCount),</b> який може видаляти та
          додавати елементи:
        </p>
        <pre>
          const numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];

          numbers.splice(4, 2); // починаючи з індекса 4 видаляє 2 елементи

          console.log(numbers); // [0, 1, 2, 3, 6, 7, 8, 9]

        </pre>
        <p>Результатом метода splice є масив видалених елементів:</p>
        <pre>
          const numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
          const deletedElements = numbers.splice(4, 2);

          console.log(deletedElements); // [4, 5]

        </pre>
        <p>Також він підтримує від'ємні індекси:</p>
        <pre>
          const numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];

          numbers.splice(-4, 2); // відраховуємо 4 з кінця

          console.log(numbers); // [0, 1, 2, 3, 4, 5, 8, 9]

        </pre>
        <p>
          Якщо ми хочемо додати нові елементи замість видалених, їх треба
          передати починаючи з 3 аргумента:
        </p>
        <pre>
          const numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];

          numbers.splice(4, 2, 100, 200, 300); // видаляємо 2 елементи та додаємо 3 нових замість них

          console.log(numbers); // [0, 1, 2, 3, 100, 200, 300, 6, 7, 8, 9]

        </pre>
        <p>
          Звісно можна нічого не видаляти і просто додати елементи всередину
        </p>
        <pre>
          const numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];

          numbers.splice(-2, 0, 100, 200, 300); // перед двома останніми 2 елементами додаємо 3 нових

          console.log(numbers); // [0, 1, 2, 3, 4, 5, 6, 7, 100, 200, 300, 8, 9]

        </pre>
        <h3 class="main-topic-title">Перевпорядкування елементів масиву</h3>
        <hr />
        <p>
          Щоб переставити елементи масиву у зворотньому порядку, існує метод
          reverse:
        </p>
        <pre>
          const numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];

          numbers.reverse();

          console.log(numbers); // [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]

        </pre>
        <p>
          Також є метод sort, який дозволяю впорядкувати елементи за зростанням:
        </p>
        <pre>
          const numbers = [3, 7, 2, 0, 3, 4];

          numbers.sort();

          console.log(number); // [0, 2, 3, 3, 4, 7];

        </pre>
        <p>Рядки він розміщую в алфавітному порядку:</p>
        <pre>
          const letters = 'banana'.split('')

          letters.sort()

          console.log(letters.join('')); // 'aaabnn'

        </pre>
        <p>
          Але це не працює корректно для великих літер, та чисел довших за 1
          цифру, бо сортування завжди відбувається по кодах символів, навіть
          якщо це числа:
        </p>
        <pre>
          const numbers = [12, 100, 9, 25];
          const letters = 'AbCdXyZ'.split('');

          numbers.sort();
          letters.sort()

          console.log(numbers); // [100, 12, 25, 9]
          console.log(letters.join('')); // 'ACXZbdy'

        </pre>
        <p>
          Як вирішити цю проблему, ми розглянемо в уроці про перебираючі методи
          масивів.
        </p>
        <h3 class="main-topic-title">Об'єднання масивів</h3>
        <hr />
        <p>Для об'єднання декількох масивів є метод <b>concat:</b></p>
        <pre>
          const first = [1, 2, 3];
          const second = [10, 20, 30];

          const result = first.concat(second);

          console.log(result); // [1, 2, 3, 10, 20, 30];

        </pre>
        <p>Так можна поєднати декілька елементів та окремих значень:</p>
        <pre>
          const first = [1, 2, 3];
          const second = [10, 20, 30];

          console.log(
            [42, 99].concat(0, first, 4, 5, second), // [42, 99, 0, 1, 2, 3, 4, 5, 10, 20, 30]
          )

        </pre>
        <p>Того ж результату можна досягти за допомогою спред оператора:</p>
        <pre>
          const first = [1, 2, 3];
          const second = [10, 20, 30];

          const result = [...first, ...second];
          console.log(result); // [1, 2, 3, 10, 20, 30];

          const otherResult = [0, ...first, 4, 5, ...second];
          console.log(otherResult); // [0, 1, 2, 3, 4, 5, 10, 20, 30]

        </pre>
        <h3 class="main-topic-title">Копіювання масиву</h3>
        <hr />
        <p>
          Для створення точної копії масиву можна скористатися одним з методів,
          які ми розглядали вище:
        </p>
        <pre>
          const numbers = [1, 2, 3, 4, 5, 6, 7];

          const copy1 = [...numbers];
          const copy2 = Array.from(numbers);
          const copy3 = numbers.concat();
          const copy4 = numbers.slice();

        </pre>
        <p>Мутуючі та не мутуючі методи</p>
        <p>
          <b>Мутацією називають зміну масиву чи об'єкту.</b> Пізніше, при
          вивченні React, ми обговоримо, коли може бути важливо уникати мутації
          даних. Для того, щоб уникати мутації, потрібно розуміти, які методи є
          мутуючіми, а які ні.
        </p>
        <p>
          Використай наступний код, що побачити, як працюють методи, які ми
          розглянули в цьому уроці:
        </p>
        <pre>
          'use strict';

          const numbers = [3, 1, 12, 5, 2, 3, 4];
          let result;

          console.log(numbers);

          /*  Mutating methods */
          result = numbers.push(100, 200, 300);
          // result = numbers.unshift(100, 200, 300);
          // result = numbers.pop();
          // result = numbers.shift();
          // result = numbers.splice(2, 3, 100, 200, 300, 400);
          // result = numbers.fill('a', 2, 5);
          // result = numbers.reverse();
          // result = numbers.sort();

          /* Non mutating methods */
          // result = numbers.includes(3);
          // result = numbers.indexOf(3);
          // result = numbers.lastIndexOf(3);
          // result = numbers.join('-');
          // result = numbers.slice(2, 5);
          // result = numbers.concat(100, ['x', 'y', 999], 200, 300);

          console.log('---------');

          console.log(numbers);
          console.log(result);

        </pre>
        <p>
          Також для зручності в методів reverse, sort та splice нещодавно
          з'явилися немутуючі аналоги
          <a
            href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toReversed"
            target="_blank"
          >
            toReversed
          </a>
          <a
            href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toSorted"
            target="_blank"
          >
            toSorted
          </a>
          <a
            href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toSpliced"
            target="_blank"
          >
            toSpliced.
          </a>
        </p>
      </section>
      <section class="destructuringArray" id="Destructuring-Array">
        <h2 class="main-topic-title">
          Destructuring an Array / Деструктуризация Массивов
        </h2>
        <hr />
        <p>
          Якщо нам потрібно зберегти окремі елементи масиву до змінних, можна
          зробити це за допомогою деструктурованого присвоєння:
        </p>
        <pre>
          const daysOfWeek = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];
          const [first, second] = daysOfWeek;

          console.log(first); // 'Mon'
          console.log(second); // 'Tue'

        </pre>
        <p>За бажанням можна пропустити деякі елементи поставивши коми:</p>
        <pre>
          const daysOfWeek = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];
          const [,,third,,fifth] = daysOfWeek;

          console.log(third); // 'Wed'
          console.log(fifth); // 'Fri'

        </pre>
        <p>
          Також підчас деструктурування масиву можна зібрати решту елементів в
          новий масив за допомогою rest оператора, аналогічно до того, як ми
          збираємо в масив аргументи функції що залишилися:
        </p>
        <pre>
          const daysOfWeek = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];
          const [first, second, ...otherDays] = daysOfWeek;

          console.log(otherDays); // ['Wed', 'Thu', 'Fri', 'Sat', 'Sun']

        </pre>
        <p>
          Деструктурування масиву можна робити і в параметрах функції, якщо ми
          передаємо до неї масив, як один з аргументів:
        </p>
        <pre>
          function printTwoFirstElements([first, second]) {
            console.log(first, second);
          }
          
          printTwoFirstElements([1, 2, 3, 4, 5]); // 1 2
          printTwoFirstElements('abdcefgh'.split('')); // a b
          
        </pre>
      </section>
      <sectuon class="Useful-links">
        <p>
          <a href="https://mate-academy.github.io/fe-program/js/extra/array">
            Array Methods Cheatsheet
          </a>
        </p>
        <p>
          <a href="https://javascript.info/array-methods">Array methods</a>
        </p>
      </sectuon>
    </div>

    <script src="main.js"></script>
  </body>
</html>
